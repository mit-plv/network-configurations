Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Program.Equality.
Require Import ZArith.

Section Node.
  Variable Node : Set.

  Record flow := {
    Src : Node;
    Dest : Node
  }.

  Definition network_topology := Node -> Node -> Prop.

  Definition network_policy := flow -> bool.

  Definition next_node := Node -> flow -> Node -> Prop.

  Fixpoint is_next_node_path (next : next_node) path here current_flow :=
    match path with
    | [] => here = current_flow.(Dest)
    | hop_target :: cdr =>
        next here current_flow hop_target /\
        is_next_node_path next cdr hop_target current_flow
    end.

  Record next_node_valid (topology : network_topology) (policy : network_policy) (next : next_node) := {
    all_hops_in_topology : forall here current_flow hop_target,
      next here current_flow hop_target -> topology here hop_target;

    path_exists_only_for_valid_flows : forall current_flow,
      current_flow.(Src) <> current_flow.(Dest)
        -> (policy current_flow = true <-> exists path,
              is_next_node_path next path current_flow.(Src) current_flow);

    no_black_holes : forall src current_flow hop_target,
      next src current_flow hop_target
        -> exists path, is_next_node_path next path hop_target current_flow;

    all_paths_acyclic : forall path here current_flow,
      is_next_node_path next path here current_flow -> NoDup (here :: path)
  }.

  Definition dec_next_node := Node -> flow -> option Node.

  Definition dec_next_node_valid (topology : network_topology) (policy : network_policy) (dec_next : dec_next_node) :=
    next_node_valid topology policy (fun here current_flow hop_target => dec_next here current_flow = Some hop_target).

  Fixpoint is_path_in_topology (topology : network_topology) src dest path :=
    match path with
    | [] => src = dest
    | hop_target :: cdr =>
      topology src hop_target /\
      is_path_in_topology topology hop_target dest cdr
    end.

  Definition all_pairs_paths := Node -> Node -> option (list Node).

  Definition all_pairs_paths_next_node_generator
    (paths : all_pairs_paths)
    (topology : network_topology)
    (policy : network_policy)
    here
    current_flow
    hop_target
  :=
    policy current_flow = true /\
    match paths here current_flow.(Dest) with
    | Some (hop_target' :: _) => hop_target = hop_target'
    | _ => False
    end.

  Definition edge_costs := Node -> Node -> nat.
  (* NOTE: All pairs of nodes have an edge cost, even
     pairs that don't have an edge between them in the topology.
     This is logically consistent (the costs for the pairs that
     aren't in the topology won't get used), but perhaps unintuitive. *)

  Definition only_positive_costs (costs : edge_costs) := forall n1 n2,
    costs n1 n2 > 0.

  Fixpoint path_cost (costs : edge_costs) src path :=
    match path with
    | [] => 0
    | car :: cdr => costs src car + path_cost costs car cdr
    end.

  Definition generates_decreasing_costs (paths : all_pairs_paths) costs :=
    only_positive_costs costs /\
    forall src dest,
      match paths src dest with
      | Some (hop_target :: cdr) =>
        match paths hop_target dest with
        | Some path => path_cost costs hop_target path < path_cost costs src (hop_target :: cdr)
        | None => False
        end
      | _ => True
      end.

  Record all_pairs_paths_valid paths topology policy := {
    paths_in_topology : forall src dest,
      match paths src dest with
      | Some path => is_path_in_topology topology src dest path
      | _ => True
      end;
    paths_exist_for_valid_flows : forall current_flow,
      policy current_flow = true
        ->
          match paths current_flow.(Src) current_flow.(Dest) with
          | Some _ => True
          | None => False
          end;

    (* The consumer needs to show that some global cost function exists
       for which every hop on a path generated by `paths` will decrease
       the estimated total cost of the remainder the path. This is a
       sufficient condition to show prove the absence of cycles.
       (In practice, the consumer would likely start out with the cost function
       as an input based on environmental factors, then use it to generate
       a valid all-pairs paths function.) *)
    paths_move_closer_to_destination : exists (costs : edge_costs),
      generates_decreasing_costs paths costs
  }.

  Lemma all_pairs_paths_next_node_generator_creates_next_node_paths : forall paths topology policy current_flow hop_target,
    all_pairs_paths_valid paths topology policy
      -> policy current_flow = true
      -> match paths hop_target current_flow.(Dest) with | Some _ => True | None => False end
      -> exists path,
        is_next_node_path (all_pairs_paths_next_node_generator paths topology policy) path hop_target current_flow.
  Proof.
    intros.
    remember (paths hop_target current_flow.(Dest)) as x.
    destruct x; try tauto.
    clear H1.
    assert (H' := H).
    apply paths_move_closer_to_destination in H'.
    destruct H'.
    destruct H1.
    remember (path_cost x hop_target l) as cost.
    assert (match paths hop_target current_flow.(Dest) with | Some p => path_cost x hop_target p <= cost | _ => False end) by (rewrite <- Heqx; omega).
    assert (cost = 0 -> hop_target = current_flow.(Dest)).
    - intros.
      subst.
      destruct l.
      + eapply paths_in_topology in H.
        rewrite <- Heqx in H.
        tauto.
      + simpl in H4.
        unfold only_positive_costs in H1.
        specialize (H1 hop_target).
        specialize (H1 n).
        omega.
    - clear Heqcost.
      clear Heqx.
      dependent induction cost generalizing hop_target; try (exists []; tauto).
      clear H4.
      remember (paths hop_target current_flow.(Dest)) as p.
      destruct p; try tauto.
      destruct l0; try (exists []; simpl; eapply paths_in_topology in H; rewrite <- Heqp in H; simpl in H; subst; reflexivity).
      specialize (H2 hop_target).
      specialize (H2 current_flow.(Dest)).
      rewrite <- Heqp in H2.
      specialize (IHcost n).
      destruct (paths n current_flow.(Dest)); try tauto.
      assert (path_cost x n l1 <= cost) by omega.
      apply IHcost in H4.
      + destruct H4.
        exists (n :: x0).
        simpl.
        constructor; try assumption.
        unfold all_pairs_paths_next_node_generator.
        constructor; try assumption.
        rewrite <- Heqp.
        reflexivity.
      + intros.
        subst.
        simpl in H3.
        assert (x hop_target n > 0) by (apply H1).
        assert (path_cost x n l0 = 0) by omega.
        destruct l0; simpl in H6.
        * eapply paths_in_topology in H.
          rewrite <- Heqp in H.
          simpl in H.
          tauto.
        * assert (x n n0 > 0) by (apply H1).
          omega.
  Qed.

  Fixpoint has_strictly_decreasing_costs (paths : all_pairs_paths) (costs : edge_costs) l dest bound :=
    match l with
    | [] => True
    | node :: cdr =>
      match paths node dest with
      | Some l' => path_cost costs node l' < bound /\ has_strictly_decreasing_costs paths costs cdr dest (path_cost costs node l')
      | None => False
      end
    end.

  Lemma strictly_decreasing_costs_strengthening : forall paths costs l dest small_bound big_bound,
    has_strictly_decreasing_costs paths costs l dest small_bound
      -> small_bound <= big_bound
      -> has_strictly_decreasing_costs paths costs l dest big_bound.
  Proof.
    intros.
    destruct l; simpl; try tauto.
    simpl in H.
    destruct (paths n dest); try tauto.
    destruct H.
    constructor; try tauto; omega.
  Qed.

  Lemma all_pairs_paths_generate_strictly_decreasing_costs : forall (paths : all_pairs_paths) costs topology policy here current_flow path path',
    generates_decreasing_costs paths costs
      -> paths here current_flow.(Dest) = Some path'
      -> is_next_node_path (all_pairs_paths_next_node_generator paths topology policy) path here current_flow
      -> has_strictly_decreasing_costs paths costs path current_flow.(Dest) (path_cost costs here path').
  Proof.
    intros.
    dependent induction path generalizing here; try (simpl; tauto).
    simpl.
    simpl in H1.
    destruct H1.
    unfold all_pairs_paths_next_node_generator in H1.
    destruct H1.
    rewrite H0 in H3.
    destruct path'; try tauto.
    subst.
    assert (H' := H).
    destruct H'.
    specialize (H4 here).
    specialize (H4 current_flow.(Dest)).
    rewrite H0 in H4.
    remember (paths n current_flow.(Dest)) as p.
    apply eq_sym in Heqp.
    destruct p; try tauto.
    constructor; try assumption.
    apply IHpath; assumption.
  Qed.


  Lemma decreasing_costs_implies_nonmember : forall (paths : all_pairs_paths) costs path dest node path',
    paths node dest = Some path'
      -> has_strictly_decreasing_costs paths costs path dest (path_cost costs node path')
      -> ~In node path.
  Proof.
    intros.
    dependent induction path; intros; simpl; try tauto.
    simpl in H0.
    remember (paths a dest) as l.
    destruct l; try tauto.
    destruct H0.
    unfold not.
    intros.
    destruct H2.
    - subst.
      rewrite <- Heql in H.
      injection H.
      intros.
      subst.
      omega.
    - assert (~(In node path)); try tauto.
      apply strictly_decreasing_costs_strengthening with (big_bound := path_cost costs node path') in H1; try omega.
      eapply IHpath; eassumption.
  Qed.

  Lemma NoDup_single : forall A (el : A), NoDup [el].
  Proof.
    intros.
    constructor.
    - unfold not; intros.
      inversion H.
    - constructor.
  Qed.

  Theorem all_pairs_paths_generator_valid : forall paths topology policy,
    all_pairs_paths_valid paths topology policy
      -> next_node_valid topology policy (all_pairs_paths_next_node_generator paths topology policy).
  Proof.
    intros.
    constructor; intros.
    - unfold all_pairs_paths_next_node_generator in H0.
      destruct H0.
      apply paths_in_topology with (src := here) (dest := current_flow.(Dest)) in H.
      destruct (paths here current_flow.(Dest)); try tauto.
      destruct l; try tauto.
      subst.
      simpl in H.
      tauto.
    - constructor.
      + intros.
        apply all_pairs_paths_next_node_generator_creates_next_node_paths; try assumption.
        eapply paths_exist_for_valid_flows in H; eassumption.
      + intros.
        destruct H1.
        destruct x; simpl in H1; try tauto.
        destruct H1.
        unfold all_pairs_paths_next_node_generator in H1.
        tauto.
    - unfold all_pairs_paths_next_node_generator in H0.
      destruct H0.
      apply all_pairs_paths_next_node_generator_creates_next_node_paths; try tauto.
      remember (paths src current_flow.(Dest)) as p.
      destruct p; try tauto.
      destruct l; try tauto.
      subst.
      apply paths_move_closer_to_destination in H.
      destruct H.
      destruct H.
      specialize (H1 src).
      specialize (H1 current_flow.(Dest)).
      rewrite <- Heqp in H1.
      destruct (paths n current_flow.(Dest)); tauto.
    - dependent induction path; try apply NoDup_single.
      simpl in H0.
      destruct H0.
      unfold all_pairs_paths_next_node_generator in H0.
      destruct H0.
      remember (paths here current_flow.(Dest)) as p.
      destruct p; try tauto.
      destruct l; try tauto.
      subst.
      assert (H1' := H1).
      apply IHpath in H1.
      constructor; try assumption.
      unfold not.
      intros.
      destruct H2.
      + subst.
        apply paths_move_closer_to_destination in H.
        destruct H.
        destruct H.
        specialize (H2 here).
        specialize (H2 current_flow.(Dest)).
        rewrite <- Heqp in H2.
        rewrite <- Heqp in H2.
        simpl in H2.
        omega.
      + assert (~(In here path)); try tauto.
        apply paths_move_closer_to_destination in H.
        destruct H.
        eapply decreasing_costs_implies_nonmember with (costs := x).
        * apply eq_sym.
          eassumption.
        * assert (H' := H).
          destruct H'.
          specialize (H4 here).
          specialize (H4 current_flow.(Dest)).
          rewrite <- Heqp in H4.
          remember (paths n current_flow.(Dest)) as p.
          destruct p; try tauto.
          apply strictly_decreasing_costs_strengthening with (small_bound := path_cost x n l0); try omega.
          apply eq_sym in Heqp0.
          eapply all_pairs_paths_generate_strictly_decreasing_costs; eassumption.
  Qed.

  Definition all_pairs_paths_dec_next_node_generator
    (paths : all_pairs_paths)
    (topology : network_topology)
    (policy : network_policy)
    here
    current_flow
  :=
    if policy current_flow then
      match paths here current_flow.(Dest) with
      | Some (hop_target :: _) => Some hop_target
      | _ => None
      end
    else None.

  Lemma is_next_node_path_weakening : forall (strict_next lenient_next : next_node) path here current_flow,
    is_next_node_path strict_next path here current_flow
      -> (forall here' current_flow' hop_target, strict_next here' current_flow' hop_target -> lenient_next here' current_flow' hop_target)
      -> is_next_node_path lenient_next path here current_flow.
  Proof.
    intros.
    dependent induction path; simpl; simpl in H; try assumption.
    destruct H.
    assert (H0' := H0).
    apply IHpath with (here := a) (current_flow := current_flow) in H0; try tauto.
    constructor; try tauto.
    apply H0'; assumption.
  Qed.

  Lemma next_node_extensionality : forall next1 next2 topology policy,
    (forall here current_flow hop_target, next1 here current_flow hop_target <-> next2 here current_flow hop_target)
      -> next_node_valid topology policy next1
      -> next_node_valid topology policy next2.
  Proof.
    intros.
    constructor; intros; destruct H0.
    - eapply all_hops_in_topology0.
      apply H.
      eassumption.
    - constructor; intros.
      + apply path_exists_only_for_valid_flows0 in H0; try assumption.
        destruct H0.
        exists x.
        eapply is_next_node_path_weakening; try eassumption; apply H.
      + apply path_exists_only_for_valid_flows0 in H1.
        destruct H1.
        apply H2.
        destruct H0.
        exists x.
        eapply is_next_node_path_weakening; try eassumption; apply H.
    - apply H in H1.
      apply no_black_holes0 in H1.
      destruct H1.
      exists x.
      eapply is_next_node_path_weakening; try eassumption; apply H.
    - eapply is_next_node_path_weakening in H1; try apply H.
      apply all_paths_acyclic0 in H1.
      assumption.
  Qed.

  Theorem all_pairs_paths_dec_generator_valid : forall paths topology policy,
    all_pairs_paths_valid paths topology policy
      -> dec_next_node_valid topology policy (all_pairs_paths_dec_next_node_generator paths topology policy).
  Proof.
    intros.
    apply all_pairs_paths_generator_valid in H.
    eapply next_node_extensionality; try eassumption.
    unfold all_pairs_paths_next_node_generator, all_pairs_paths_dec_next_node_generator.
    constructor; intros; repeat match goal with
    | [ H : _ /\ _ |- _ ] => destruct H
    | [ _ : _ |- _ /\ _ ] => constructor
    | [ H : context[match ?x with _ => _ end] |- _ ] => destruct x
    | [ H : ?x = _ |- context[?x] ] => rewrite H
    | [ H : _ ?a = _ ?b |- ?b = ?a ] => injection H; apply eq_sym
    | _ => tauto
    | _ => discriminate
    end.
  Qed.

  Definition routing_tables := Node -> list (flow * Node).

  Record routing_tables_valid (tables : routing_tables) (dec_next : dec_next_node) := {
    no_duplicate_entries : forall here,
      NoDup (tables here);

    (* FIXME: the constraint below might be unnecessary/overly restrictive in practice. *)
    no_conflicting_entries : forall here current_flow target1 target2,
      In (current_flow, target1) (tables here)
        -> In (current_flow, target2) (tables here)
        -> target1 = target2;

    entries_match_next_node_result : forall here current_flow hop_target,
      dec_next here current_flow = Some hop_target
        <-> In (current_flow, hop_target) (tables here)
  }.

  Definition routing_tables_generator := dec_next_node -> list Node -> routing_tables.

  Definition valid_node_enumeration (all_nodes : list Node) := forall node, In node all_nodes.

  Definition routing_tables_generator_valid (generator : routing_tables_generator) := forall dec_next all_nodes,
    valid_node_enumeration all_nodes
      -> NoDup all_nodes
      -> routing_tables_valid
        (generator dec_next all_nodes)
        dec_next.

  Fixpoint all_distinct_pairs {A} (sequence : list A) :=
    match sequence with
    | [] => []
    | (car :: cdr) => (car, car) :: map (fun n => (car, n)) cdr ++ map (fun n => (n, car)) cdr ++ all_distinct_pairs cdr
    end.

  (* Sanity check until exhaustive_routing_tables_generator_valid is proven below *)
  Lemma all_distinct_pairs_test : all_distinct_pairs [1; 2; 3]
    = [(1, 1); (1, 2); (1, 3); (2, 1); (3, 1); (2, 2); (2, 3); (3, 2); (3, 3)].
  Proof.
    reflexivity.
  Qed.

  Fixpoint map_filter {A} {B} (mapper : A -> option B) (l : list A) :=
    match l with
    | [] => []
    | car :: cdr =>
      match mapper car with
      | Some car' => car' :: map_filter mapper cdr
      | None => map_filter mapper cdr
      end
    end.

  Definition fst {A} {B} (pair : A * B) := match pair with | (l, _) => l end.
  Definition snd {A} {B} (pair : A * B) := match pair with | (_, r) => r end.

  Definition exhaustive_routing_tables_generator (dec_next : dec_next_node) (all_nodes : list Node) (here : Node) :=
    map_filter (fun pair =>
      match dec_next here {| Src := fst pair; Dest := snd pair |} with
      | Some hop_target => Some ({| Src := fst pair; Dest := snd pair |}, hop_target)
      | None => None
      end
    ) (all_distinct_pairs all_nodes).

  Theorem exhaustive_routing_tables_generator_valid : routing_tables_generator_valid exhaustive_routing_tables_generator.
  Proof.
    (* TODO *)
  Abort.
End Node.

Ltac enumerate_finite_set Node :=
  match goal with
  | [ |- {l : list Node | valid_node_enumeration Node l} ] => idtac
  | _ => fail 1
  end;
  econstructor;
  unfold valid_node_enumeration;
  intros;
  match goal with
  | [ node : Node |- _ ] => destruct node
  end;
  unshelve (
    let cdr := fresh "cdr" in
      evar (cdr : list Node);
      let cdr' := eval unfold cdr in cdr in
        clear cdr;
        match goal with
        | [ |- In ?n _ ] => instantiate (1 := n :: cdr')
        end;
        simpl;
        tauto
  );
  exact [].


Require Import ZArith.
Section NetworkExample.
  Local Inductive ExampleVertex :=
  | A
  | B
  | C
  | D
  | E
  | F
  .

  (*
    example_topology:

        B ------> E
      / | \       â†‘
     A  |5 D <--- F
      \ | /
        C
  *)
  Local Definition example_topology n1 n2 :=
    match n1, n2 with
    | A, B | B, A => True
    | A, C | C, A => True
    | B, C | C, B => True
    | B, D | D, B => True
    | B, E => True
    | C, D | D, C => True
    | F, D => True
    | F, E => True
    | _, _ => False
    end.

  Local Definition example_all_pairs_paths n1 n2 :=
    match n1, n2 with
    | A, A | B, B | C, C | D, D | E, E | F, F => Some []
    | A, B => Some [C; B]
    | A, C => Some [C]
    | A, D => Some [B; D]
    | A, E => Some [B; E]
    | A, F => None
    | B, A => Some [A]
    | B, C => Some [C]
    | B, D => Some [D]
    | B, E => Some [E]
    | B, F => None
    | C, A => Some [A]
    | C, B => Some [B]
    | C, D => Some [D]
    | C, E => Some [A; B; E]
    | C, F => None
    | D, A => Some [C; A]
    | D, B => Some [B]
    | D, C => Some [C]
    | D, E => Some [C; A; B; E]
    | D, F => None
    | E, _ => None
    | F, A => Some [D; B; A]
    | F, B => Some [D; B]
    | F, C => Some [D; C]
    | F, D => Some [D]

    (* a route which won't actually get followed because D will reroute *)
    | F, E => Some [D; C; B; E]
    end.

  (* Giving all edges a cost of 1 would not satisfy the decreasing-costs
  constraint, because when routing F to E, node B would choose
  a path of [C; A; B; E] which is not shorter than the original expected
  path from F of [D; C; B; E]. However, if the (C, B) edge
  has a large cost, then the total cost of [C; A; B; E] is less
  than the cost of [D; C; B; E]. *)
  Definition example_costs n1 n2 :=
    match n1, n2 with
    | C, B => 5
    | _, _ => 1
    end.

  Definition policy_satisfiable (policy : network_policy ExampleVertex) := forall n1 n2,
    policy {| Src := n1; Dest := n2 |} = true -> example_all_pairs_paths n1 n2 <> None.

  Local Lemma paths_valid : forall policy,
    policy_satisfiable policy
      -> all_pairs_paths_valid ExampleVertex example_all_pairs_paths example_topology policy.
  Proof.
    intros.
    constructor; intros.
    - destruct src, dest; unfold example_topology; simpl; tauto.
    - destruct current_flow.
      simpl.
      apply H in H0.
      destruct (example_all_pairs_paths Src0 Dest0); tauto.
    - exists example_costs.
      constructor; try (unfold only_positive_costs, example_costs; intros; destruct n1, n2; omega).
      intros.
      destruct src, dest; simpl; try omega; tauto.
  Qed.

  Local Theorem validity : forall policy,
    policy_satisfiable policy
      -> next_node_valid ExampleVertex example_topology policy
        (all_pairs_paths_next_node_generator ExampleVertex example_all_pairs_paths example_topology policy).
  Proof.
    intros.
    apply all_pairs_paths_generator_valid.
    apply paths_valid; assumption.
  Qed.

  Local Theorem dec_validity : forall policy,
    policy_satisfiable policy
      -> dec_next_node_valid ExampleVertex example_topology policy
        (all_pairs_paths_dec_next_node_generator ExampleVertex example_all_pairs_paths example_topology policy).
    Proof.
      intros.
      apply all_pairs_paths_dec_generator_valid.
      apply paths_valid; assumption.
    Qed.

  Local Definition example_policy current_flow :=
    match Src ExampleVertex current_flow, Dest ExampleVertex current_flow with
    | A, _ | _, A | F, _ | _, F => true
    | _, _ => false
    end.

  Definition example_dec_next_node := all_pairs_paths_dec_next_node_generator ExampleVertex example_all_pairs_paths example_topology example_policy.

  Local Definition example_enumeration: {l : list ExampleVertex | valid_node_enumeration ExampleVertex l} :=
    ltac:(enumerate_finite_set ExampleVertex).

  Local Definition example_routing_tables := exhaustive_routing_tables_generator ExampleVertex example_dec_next_node (proj1_sig example_enumeration).

  Definition concrete_routing_tables := map (fun n => (n, example_routing_tables n)) (proj1_sig example_enumeration).

  Compute concrete_routing_tables.

  (* Note: this proof takes a very long time. It's probably worth proving the general
    case of validity here rather than using brute force per-example. *)
  Local Theorem example_routing_tables_valid : routing_tables_valid ExampleVertex example_routing_tables example_dec_next_node.
  Proof.
    constructor; intros.
    - destruct here; simpl; try tauto; repeat match goal with
      | [ |- _ /\ _ ] => constructor
      | [ |- ~_ ] => unfold not; intros
      | [ H : _ \/ _ |- _ ] => destruct H
      | _ => tauto
      | _ => discriminate
      end.
    - destruct here, target1, target2; simpl in H, H0; repeat match goal with
      | [ |- ?n = ?n ] => reflexivity
      | [ H : _ \/ _ |- _ ] => destruct H
      | [ H : False |- _ ] => destruct H
      | [ H : (_, _) = (_, _) |- _ ] => injection H; intros; subst; discriminate
      end.
    - unfold example_dec_next_node, all_pairs_paths_dec_next_node_generator.
      destruct current_flow, here, Src0, Dest0, hop_target; simpl; constructor; intros; try discriminate; repeat match goal with
      | [ H : _ \/ _ |- _ ] => destruct H
      | [ H : False |- _ ] => destruct H
      | _ => discriminate
      | _ => tauto
      end.
  Qed.
End NetworkExample.
