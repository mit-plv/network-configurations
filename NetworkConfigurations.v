Require Import Coq.Lists.List.
Require Import Coq.Program.Equality.
Require Import ZArith.

Section Node.
  Variable Node : Set.

  Record flow := {
    Src : Node;
    Dest : Node
  }.

  Definition network_topology := Node -> Node -> Prop.

  Definition network_policy := flow -> bool.

  Definition next_node := Node -> flow -> Node -> Prop.

  Fixpoint is_next_node_path (next : next_node) path here current_flow :=
    match path with
    | nil => here = current_flow.(Dest)
    | cons hop_target cdr =>
        next here current_flow hop_target /\
        is_next_node_path next cdr hop_target current_flow
    end.

  Fixpoint contains_no_duplicates {A} (l : list A) :=
    match l with
    | nil => True
    | cons car cdr => ~In car cdr /\ contains_no_duplicates cdr
    end.

  Record next_node_valid (topology : network_topology) (policy : network_policy) (next : next_node) := {
    all_hops_in_topology : forall here current_flow hop_target,
      next here current_flow hop_target -> topology here hop_target;

    path_exists_only_for_valid_flows : forall current_flow,
      current_flow.(Src) <> current_flow.(Dest)
        -> (policy current_flow = true <-> exists path,
              is_next_node_path next path current_flow.(Src) current_flow);

    no_black_holes : forall src current_flow hop_target,
      next src current_flow hop_target
        -> exists path, is_next_node_path next path hop_target current_flow;

    all_paths_acyclic : forall path here current_flow,
      is_next_node_path next path here current_flow -> contains_no_duplicates (here :: path)
  }.

  Fixpoint is_path_in_topology (topology : network_topology) src dest path :=
    match path with
    | nil => src = dest
    | cons hop_target cdr =>
      topology src hop_target /\
      is_path_in_topology topology hop_target dest cdr
    end.

  Definition next_node_generator := network_topology -> network_policy -> next_node.

  Definition next_node_generator_valid (generator : next_node_generator) := forall topology policy,
    next_node_valid topology policy (generator topology policy).

  Definition all_pairs_paths := Node -> Node -> option (list Node).

  Definition all_pairs_paths_next_node_generator
    (paths : all_pairs_paths)
    (topology : network_topology)
    (policy : network_policy)
    here
    current_flow
    hop_target
  :=
    policy current_flow = true /\
    match paths here current_flow.(Dest) with
    | Some (hop_target' :: _) => hop_target = hop_target'
    | _ => False
    end.

  Definition edge_costs := Node -> Node -> nat.
  (* NOTE: All pairs of nodes have an edge cost, even
     pairs that don't have an edge between them in the topology.
     This is logically consistent (the costs for the pairs that
     aren't in the topology won't get used), but perhaps unintuitive. *)

  Definition only_positive_costs (costs : edge_costs) := forall n1 n2,
    costs n1 n2 > 0.

  Fixpoint path_cost (costs : edge_costs) src path :=
    match path with
    | nil => 0
    | car :: cdr => costs src car + path_cost costs car cdr
    end.

  Definition generates_decreasing_costs (paths : all_pairs_paths) costs :=
    only_positive_costs costs /\
    forall src dest,
      match paths src dest with
      | Some (hop_target :: cdr) =>
        match paths hop_target dest with
        | Some path => path_cost costs hop_target path < path_cost costs src (hop_target :: cdr)
        | None => False
        end
      | _ => True
      end.

  Record all_pairs_paths_valid paths topology policy := {
    paths_in_topology : forall src dest,
      match paths src dest with
      | Some path => is_path_in_topology topology src dest path
      | _ => True
      end;
    paths_exist_for_valid_flows : forall current_flow,
      policy current_flow = true
        ->
          match paths current_flow.(Src) current_flow.(Dest) with
          | Some _ => True
          | None => False
          end;

    (* The consumer needs to show that some global cost function exists
       for which every hop on a path generated by `paths` will decrease
       the estimated total cost of the remainder the path. This is a
       sufficient condition to show prove the absence of cycles.
       (In practice, the consumer would likely start out with the cost function
       as an input based on environmental factors, then use it to generate
       a valid all-pairs paths function.) *)
    paths_move_closer_to_destination : exists (costs : edge_costs),
      generates_decreasing_costs paths costs
  }.

  Lemma all_pairs_paths_next_node_generator_creates_next_node_paths : forall paths topology policy current_flow hop_target,
    all_pairs_paths_valid paths topology policy
      -> policy current_flow = true
      -> match paths hop_target current_flow.(Dest) with | Some _ => True | None => False end
      -> exists path,
        is_next_node_path (all_pairs_paths_next_node_generator paths topology policy) path hop_target current_flow.
  Proof.
    intros.
    remember (paths hop_target current_flow.(Dest)) as x.
    destruct x; try tauto.
    clear H1.
    assert (H' := H).
    apply paths_move_closer_to_destination in H'.
    destruct H'.
    destruct H1.
    remember (path_cost x hop_target l) as cost.
    assert (match paths hop_target current_flow.(Dest) with | Some p => path_cost x hop_target p <= cost | _ => False end) by (rewrite <- Heqx; omega).
    assert (cost = 0 -> hop_target = current_flow.(Dest)).
    - intros.
      subst.
      destruct l.
      + eapply paths_in_topology in H.
        rewrite <- Heqx in H.
        tauto.
      + simpl in H4.
        unfold only_positive_costs in H1.
        specialize (H1 hop_target).
        specialize (H1 n).
        omega.
    - clear Heqcost.
      clear Heqx.
      dependent induction cost generalizing hop_target; try (exists nil; tauto).
      clear H4.
      remember (paths hop_target current_flow.(Dest)) as p.
      destruct p; try tauto.
      destruct l0; try (exists nil; simpl; eapply paths_in_topology in H; rewrite <- Heqp in H; simpl in H; subst; reflexivity).
      specialize (H2 hop_target).
      specialize (H2 current_flow.(Dest)).
      rewrite <- Heqp in H2.
      specialize (IHcost n).
      destruct (paths n current_flow.(Dest)); try tauto.
      assert (path_cost x n l1 <= cost) by omega.
      apply IHcost in H4.
      + destruct H4.
        exists (n :: x0).
        simpl.
        constructor; try assumption.
        unfold all_pairs_paths_next_node_generator.
        constructor; try assumption.
        rewrite <- Heqp.
        reflexivity.
      + intros.
        subst.
        simpl in H3.
        assert (x hop_target n > 0) by (apply H1).
        assert (path_cost x n l0 = 0) by omega.
        destruct l0; simpl in H6.
        * eapply paths_in_topology in H.
          rewrite <- Heqp in H.
          simpl in H.
          tauto.
        * assert (x n n0 > 0) by (apply H1).
          omega.
  Qed.

  Fixpoint has_strictly_decreasing_costs (paths : all_pairs_paths) (costs : edge_costs) l dest bound :=
    match l with
    | nil => True
    | node :: cdr =>
      match paths node dest with
      | Some l' => path_cost costs node l' < bound /\ has_strictly_decreasing_costs paths costs cdr dest (path_cost costs node l')
      | None => False
      end
    end.

  Lemma strictly_decreasing_costs_strengthening : forall paths costs l dest small_bound big_bound,
    has_strictly_decreasing_costs paths costs l dest small_bound
      -> small_bound <= big_bound
      -> has_strictly_decreasing_costs paths costs l dest big_bound.
  Proof.
    intros.
    destruct l; simpl; try tauto.
    simpl in H.
    destruct (paths n dest); try tauto.
    destruct H.
    constructor; try tauto; omega.
  Qed.

  Lemma all_pairs_paths_generate_strictly_decreasing_costs : forall (paths : all_pairs_paths) costs topology policy here current_flow path path',
    generates_decreasing_costs paths costs
      -> paths here current_flow.(Dest) = Some path'
      -> is_next_node_path (all_pairs_paths_next_node_generator paths topology policy) path here current_flow
      -> has_strictly_decreasing_costs paths costs path current_flow.(Dest) (path_cost costs here path').
  Proof.
    intros.
    dependent induction path generalizing here; try (simpl; tauto).
    simpl.
    simpl in H1.
    destruct H1.
    unfold all_pairs_paths_next_node_generator in H1.
    destruct H1.
    rewrite H0 in H3.
    destruct path'; try tauto.
    subst.
    assert (H' := H).
    destruct H'.
    specialize (H4 here).
    specialize (H4 current_flow.(Dest)).
    rewrite H0 in H4.
    remember (paths n current_flow.(Dest)) as p.
    apply eq_sym in Heqp.
    destruct p; try tauto.
    constructor; try assumption.
    apply IHpath; assumption.
  Qed.


  Lemma decreasing_costs_implies_nonmember : forall (paths : all_pairs_paths) costs path dest node path',
    paths node dest = Some path'
      -> has_strictly_decreasing_costs paths costs path dest (path_cost costs node path')
      -> ~In node path.
  Proof.
    intros.
    dependent induction path; intros; simpl; try tauto.
    simpl in H0.
    remember (paths a dest) as l.
    destruct l; try tauto.
    destruct H0.
    unfold not.
    intros.
    destruct H2.
    - subst.
      rewrite <- Heql in H.
      injection H.
      intros.
      subst.
      omega.
    - assert (~(In node path)); try tauto.
      apply strictly_decreasing_costs_strengthening with (big_bound := path_cost costs node path') in H1; try omega.
      eapply IHpath; eassumption.
  Qed.

  Theorem all_pairs_paths_generator_valid : forall paths topology policy,
    all_pairs_paths_valid paths topology policy
      -> next_node_valid topology policy (all_pairs_paths_next_node_generator paths topology policy).
  Proof.
    intros.
    constructor; intros.
    - unfold all_pairs_paths_next_node_generator in H0.
      destruct H0.
      apply paths_in_topology with (src := here) (dest := current_flow.(Dest)) in H.
      destruct (paths here current_flow.(Dest)); try tauto.
      destruct l; try tauto.
      subst.
      simpl in H.
      tauto.
    - constructor.
      + intros.
        apply all_pairs_paths_next_node_generator_creates_next_node_paths; try assumption.
        eapply paths_exist_for_valid_flows in H; eassumption.
      + intros.
        destruct H1.
        destruct x; simpl in H1; try tauto.
        destruct H1.
        unfold all_pairs_paths_next_node_generator in H1.
        tauto.
    - unfold all_pairs_paths_next_node_generator in H0.
      destruct H0.
      apply all_pairs_paths_next_node_generator_creates_next_node_paths; try tauto.
      remember (paths src current_flow.(Dest)) as p.
      destruct p; try tauto.
      destruct l; try tauto.
      subst.
      apply paths_move_closer_to_destination in H.
      destruct H.
      destruct H.
      specialize (H1 src).
      specialize (H1 current_flow.(Dest)).
      rewrite <- Heqp in H1.
      destruct (paths n current_flow.(Dest)); tauto.
    - dependent induction path; try (simpl; tauto).
      simpl in H0.
      destruct H0.
      unfold all_pairs_paths_next_node_generator in H0.
      destruct H0.
      remember (paths here current_flow.(Dest)) as p.
      destruct p; try tauto.
      destruct l; try tauto.
      subst.
      assert (H1' := H1).
      apply IHpath in H1.
      simpl.
      simpl in H1.
      constructor; try tauto.
      unfold not.
      intros.
      destruct H2.
      + subst.
        apply paths_move_closer_to_destination in H.
        destruct H.
        destruct H.
        specialize (H2 here).
        specialize (H2 current_flow.(Dest)).
        rewrite <- Heqp in H2.
        rewrite <- Heqp in H2.
        simpl in H2.
        omega.
      + assert (~(In here path)); try tauto.
        apply paths_move_closer_to_destination in H.
        destruct H.
        eapply decreasing_costs_implies_nonmember with (costs := x).
        * apply eq_sym.
          eassumption.
        * assert (H' := H).
          destruct H'.
          specialize (H4 here).
          specialize (H4 current_flow.(Dest)).
          rewrite <- Heqp in H4.
          remember (paths n current_flow.(Dest)) as p.
          destruct p; try tauto.
          apply strictly_decreasing_costs_strengthening with (small_bound := path_cost x n l0); try omega.
          apply eq_sym in Heqp0.
          eapply all_pairs_paths_generate_strictly_decreasing_costs; eassumption.
  Qed.
End Node.

Require Import ZArith.
Section NetworkExample.
  Local Inductive ExampleVertex :=
  | A
  | B
  | C
  | D
  | E
  | F
  .

  (*
    example_topology:

        B ------> E
      / | \       ↑
     A  |5 D <--- F
      \ | /
        C
  *)
  Local Definition example_topology n1 n2 :=
    match (n1, n2) with
    | (A, B) | (B, A) => True
    | (A, C) | (C, A) => True
    | (B, C) | (C, B) => True
    | (B, D) | (D, B) => True
    | (B, E) => True
    | (C, D) | (D, C) => True
    | (F, D) => True
    | (F, E) => True
    | _ => False
    end.

  Local Definition example_all_pairs_paths n1 n2 :=
    match (n1, n2) with
    | (A, A) | (B, B) | (C, C) | (D, D) | (E, E) | (F, F) => Some nil
    | (A, B) => Some (C :: B :: nil)
    | (A, C) => Some (C :: nil)
    | (A, D) => Some (B :: D :: nil)
    | (A, E) => Some (B :: E :: nil)
    | (A, F) => None
    | (B, A) => Some (A :: nil)
    | (B, C) => Some (C :: nil)
    | (B, D) => Some (D :: nil)
    | (B, E) => Some (E :: nil)
    | (B, F) => None
    | (C, A) => Some (A :: nil)
    | (C, B) => Some (B :: nil)
    | (C, D) => Some (D :: nil)
    | (C, E) => Some (A :: B :: E :: nil)
    | (C, F) => None
    | (D, A) => Some (C :: A :: nil)
    | (D, B) => Some (B :: nil)
    | (D, C) => Some (C :: nil)
    | (D, E) => Some (C :: A :: B :: E :: nil)
    | (D, F) => None
    | (E, _) => None
    | (F, A) => Some (D :: B :: A :: nil)
    | (F, B) => Some (D :: B :: nil)
    | (F, C) => Some (D :: C :: nil)
    | (F, D) => Some (D :: nil)

    (* a route which won't actually get followed because D will reroute *)
    | (F, E) => Some (D :: C :: B :: E :: nil)
    end.

  (* Giving all edges a cost of 1 would not satisfy the decreasing-costs
  constraint, because when routing F to E, node B would choose
  a path of [C; A; B; E] which is not shorter than the original expected
  path from F of [D; C; B; E]. However, if the (C, B) edge
  has a large cost, then the total cost of [C; A; B; E] is less
  than the cost of [D; C; B; E]. *)
  Definition example_costs n1 n2 :=
    match (n1, n2) with
    | (C, B) => 5
    | _ => 1
    end.

  Local Theorem validity : forall (policy : network_policy ExampleVertex),
    (forall n1 n2, policy {| Src := n1; Dest := n2 |} = true -> example_all_pairs_paths n1 n2 <> None)
      -> next_node_valid ExampleVertex example_topology policy
        (all_pairs_paths_next_node_generator ExampleVertex example_all_pairs_paths example_topology policy).
  Proof.
    intros.
    apply all_pairs_paths_generator_valid.
    constructor; intros.
    - destruct src, dest; unfold example_topology; simpl; tauto.
    - destruct current_flow.
      simpl.
      apply H in H0.
      destruct (example_all_pairs_paths Src0 Dest0); tauto.
    - exists example_costs.
      constructor; try (unfold only_positive_costs, example_costs; intros; destruct n1, n2; omega).
      intros.
      destruct src, dest; simpl; try omega; tauto.
  Qed.
End NetworkExample.
