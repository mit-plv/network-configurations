Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Program.Equality.
Require Import Coq.Logic.FinFun.
Require Import Coq.Bool.Bool.
Require Import ZArith.
Require Import bbv.Word.

Section Node.
  Variable Node : Set.
  Definition Port : Set := word 16.
  Opaque Port.

  Record flow := {
    Src : Node;
    Dest : Node
  }.

  Definition network_topology := Node -> Node -> option Port.
  Definition valid_topology (topology : network_topology) := forall node outgoing1 outgoing2,
    match topology node outgoing1, topology node outgoing2 with
    | Some port1, Some port2 => port1 = port2 -> outgoing1 = outgoing2
    | _, _ => True
    end.

  Definition network_policy := flow -> bool.

  Definition next_node := Node -> flow -> Node -> Prop.

  Fixpoint is_next_node_path (next : next_node) path here current_flow :=
    match path with
    | [] => here = current_flow.(Dest)
    | hop_target :: cdr =>
        next here current_flow hop_target /\
        is_next_node_path next cdr hop_target current_flow
    end.

  Record next_node_valid (topology : network_topology) (policy : network_policy) (next : next_node) := {
    all_hops_in_topology : forall here current_flow hop_target,
      next here current_flow hop_target -> if topology here hop_target then True else False;

    path_exists_only_for_valid_flows : forall current_flow,
      (policy current_flow = true \/ current_flow.(Src) = current_flow.(Dest)) <->
      exists path,
        is_next_node_path next path current_flow.(Src) current_flow;

    no_black_holes : forall here current_flow hop_target,
      (* TODO: Should this only be a requirement when a policy allows the flow?
         Currently, this constraint requires that disallowed packets be dropped at
         the first hop in the network, which limits some implementation choices.
      *)
      next here current_flow hop_target
        -> exists path, is_next_node_path next path hop_target current_flow;

    all_paths_acyclic : forall path here current_flow,
      is_next_node_path next path here current_flow -> NoDup (here :: path)
  }.

  Definition dec_next_node := Node -> flow -> option Node.

  Definition dec_next_node_valid (topology : network_topology) (policy : network_policy) (dec_next : dec_next_node) :=
    next_node_valid topology policy (fun here current_flow hop_target => dec_next here current_flow = Some hop_target).

  Fixpoint is_path_in_topology (topology : network_topology) src dest path :=
    match path with
    | [] => src = dest
    | hop_target :: cdr =>
      (if topology src hop_target then True else False) /\
      is_path_in_topology topology hop_target dest cdr
    end.

  Definition all_pairs_paths := Node -> Node -> option (list Node).

  Definition all_pairs_paths_next_node_generator
    (paths : all_pairs_paths)
    (topology : network_topology)
    (policy : network_policy)
    here
    current_flow
    hop_target
  :=
    policy current_flow = true /\
    match paths here current_flow.(Dest) with
    | Some (hop_target' :: _) => hop_target = hop_target'
    | _ => False
    end.

  Definition edge_costs := Node -> Node -> nat.
  (* NOTE: All pairs of nodes have an edge cost, even
     pairs that don't have an edge between them in the topology.
     This is logically consistent (the costs for the pairs that
     aren't in the topology won't get used), but perhaps unintuitive. *)

  Definition only_positive_costs (costs : edge_costs) := forall n1 n2,
    costs n1 n2 > 0.

  Fixpoint path_cost (costs : edge_costs) src path :=
    match path with
    | [] => 0
    | car :: cdr => costs src car + path_cost costs car cdr
    end.

  Definition generates_decreasing_costs (paths : all_pairs_paths) costs :=
    only_positive_costs costs /\
    forall src dest,
      match paths src dest with
      | Some (hop_target :: cdr) =>
        match paths hop_target dest with
        | Some path => path_cost costs hop_target path < path_cost costs src (hop_target :: cdr)
        | None => False
        end
      | _ => True
      end.

  Record all_pairs_paths_valid topology policy paths := {
    paths_in_topology : forall src dest,
      match paths src dest with
      | Some path => is_path_in_topology topology src dest path
      | _ => True
      end;
    paths_exist_for_valid_flows : forall current_flow,
      policy current_flow = true
        ->
          match paths current_flow.(Src) current_flow.(Dest) with
          | Some _ => True
          | None => False
          end;

    (* The consumer needs to show that some global cost function exists
       for which every hop on a path generated by `paths` will decrease
       the estimated total cost of the remainder the path. This is a
       sufficient condition to show prove the absence of cycles.
       (In practice, the consumer would likely start out with the cost function
       as an input based on environmental factors, then use it to generate
       a valid all-pairs paths function.) *)
    paths_move_closer_to_destination : exists (costs : edge_costs),
      generates_decreasing_costs paths costs
  }.

  Lemma all_pairs_paths_next_node_generator_creates_next_node_paths : forall paths topology policy current_flow hop_target,
    all_pairs_paths_valid topology policy paths
      -> policy current_flow = true
      -> match paths hop_target current_flow.(Dest) with | Some _ => True | None => False end
      -> exists path,
        is_next_node_path (all_pairs_paths_next_node_generator paths topology policy) path hop_target current_flow.
  Proof.
    intros.
    destruct_with_eqn (paths hop_target current_flow.(Dest)); try tauto.
    clear H1.
    assert (H' := H).
    apply paths_move_closer_to_destination in H'.
    destruct H', H1.
    remember (path_cost x hop_target l) as cost.
    assert (match paths hop_target current_flow.(Dest) with | Some p => path_cost x hop_target p <= cost | _ => False end) by (rewrite Heqo; omega).
    assert (cost = 0 -> hop_target = current_flow.(Dest)).
    - intros.
      subst.
      destruct l.
      + eapply paths_in_topology in H.
        rewrite Heqo in H.
        tauto.
      + simpl in H4.
        unfold only_positive_costs in H1.
        specialize (H1 hop_target).
        specialize (H1 n).
        omega.
    - clear Heqcost Heqo.
      dependent induction cost generalizing hop_target; try (exists []; tauto).
      clear H4.
      destruct_with_eqn (paths hop_target current_flow.(Dest)); try tauto.
      destruct l0; try (exists []; simpl; eapply paths_in_topology in H; rewrite Heqo in H; simpl in H; subst; reflexivity).
      specialize (H2 hop_target).
      specialize (H2 current_flow.(Dest)).
      rewrite Heqo in H2.
      specialize (IHcost n).
      destruct (paths n current_flow.(Dest)); try tauto.
      assert (path_cost x n l1 <= cost) by omega.
      apply IHcost in H4.
      + destruct H4.
        exists (n :: x0).
        simpl.
        constructor; try assumption.
        unfold all_pairs_paths_next_node_generator.
        constructor; try assumption.
        rewrite Heqo.
        reflexivity.
      + intros.
        subst.
        simpl in H3.
        assert (x hop_target n > 0) by (apply H1).
        assert (path_cost x n l0 = 0) by omega.
        destruct l0; simpl in H6.
        * eapply paths_in_topology in H.
          rewrite Heqo in H.
          simpl in H.
          tauto.
        * assert (x n n0 > 0) by (apply H1).
          omega.
  Qed.

  Fixpoint has_strictly_decreasing_costs (paths : all_pairs_paths) (costs : edge_costs) l dest bound :=
    match l with
    | [] => True
    | node :: cdr =>
      match paths node dest with
      | Some l' => path_cost costs node l' < bound /\ has_strictly_decreasing_costs paths costs cdr dest (path_cost costs node l')
      | None => False
      end
    end.

  Lemma strictly_decreasing_costs_strengthening : forall paths costs l dest small_bound big_bound,
    has_strictly_decreasing_costs paths costs l dest small_bound
      -> small_bound <= big_bound
      -> has_strictly_decreasing_costs paths costs l dest big_bound.
  Proof.
    intros.
    destruct l; simpl; try tauto.
    simpl in H.
    destruct (paths n dest); try tauto.
    destruct H.
    constructor; try tauto; omega.
  Qed.

  Lemma all_pairs_paths_generate_strictly_decreasing_costs : forall (paths : all_pairs_paths) costs topology policy here current_flow path path',
    generates_decreasing_costs paths costs
      -> paths here current_flow.(Dest) = Some path'
      -> is_next_node_path (all_pairs_paths_next_node_generator paths topology policy) path here current_flow
      -> has_strictly_decreasing_costs paths costs path current_flow.(Dest) (path_cost costs here path').
  Proof.
    intros.
    dependent induction path generalizing here; try (simpl; tauto).
    simpl.
    simpl in H1.
    destruct H1.
    unfold all_pairs_paths_next_node_generator in H1.
    destruct H1.
    rewrite H0 in H3.
    destruct path'; try tauto.
    subst.
    assert (H' := H).
    destruct H'.
    specialize (H4 here).
    specialize (H4 current_flow.(Dest)).
    rewrite H0 in H4.
    destruct_with_eqn (paths n current_flow.(Dest)); try tauto.
    constructor; try assumption.
    apply IHpath; assumption.
  Qed.


  Lemma decreasing_costs_implies_nonmember : forall (paths : all_pairs_paths) costs path dest node path',
    paths node dest = Some path'
      -> has_strictly_decreasing_costs paths costs path dest (path_cost costs node path')
      -> ~In node path.
  Proof.
    intros.
    dependent induction path; intros; simpl; try tauto.
    simpl in H0.
    destruct_with_eqn (paths a dest); try tauto.
    destruct H0.
    unfold not.
    intros.
    destruct H2.
    - subst.
      rewrite Heqo in H.
      injection H.
      intros.
      subst.
      omega.
    - enough (~(In node path)) by tauto.
      apply strictly_decreasing_costs_strengthening with (big_bound := path_cost costs node path') in H1; try omega.
      eapply IHpath; eassumption.
  Qed.

  Lemma NoDup_single : forall A (el : A), NoDup [el].
  Proof.
    intros.
    constructor.
    - unfold not; intros.
      inversion H.
    - constructor.
  Qed.

  Theorem all_pairs_paths_generator_valid : forall paths topology policy,
    all_pairs_paths_valid topology policy paths
      -> next_node_valid topology policy (all_pairs_paths_next_node_generator paths topology policy).
  Proof.
    intros.
    constructor; intros.
    - unfold all_pairs_paths_next_node_generator in H0.
      destruct H0.
      apply paths_in_topology with (src := here) (dest := current_flow.(Dest)) in H.
      destruct (paths here current_flow.(Dest)); try tauto.
      destruct l; try tauto.
      subst.
      simpl in H.
      tauto.
    - constructor.
      + intros.
        destruct H0.
        * apply all_pairs_paths_next_node_generator_creates_next_node_paths; try assumption.
          eapply paths_exist_for_valid_flows in H; eassumption.
        * exists [].
          simpl.
          assumption.
      + intros.
        destruct H0.
        destruct x; simpl in H0; try tauto.
        destruct H0.
        unfold all_pairs_paths_next_node_generator in H0.
        tauto.
    - unfold all_pairs_paths_next_node_generator in H0.
      destruct H0.
      apply all_pairs_paths_next_node_generator_creates_next_node_paths; try tauto.
      destruct_with_eqn (paths here current_flow.(Dest)); try tauto.
      destruct l; try tauto.
      subst.
      apply paths_move_closer_to_destination in H.
      destruct H.
      destruct H.
      specialize (H1 here).
      specialize (H1 current_flow.(Dest)).
      rewrite Heqo in H1.
      destruct (paths n current_flow.(Dest)); tauto.
    - dependent induction path; try apply NoDup_single.
      simpl in H0.
      destruct H0.
      unfold all_pairs_paths_next_node_generator in H0.
      destruct H0.
      destruct_with_eqn (paths here current_flow.(Dest)); try tauto.
      destruct l; try tauto.
      subst.
      assert (H1' := H1).
      apply IHpath in H1.
      constructor; try assumption.
      unfold not.
      intros.
      destruct H2.
      + subst.
        apply paths_move_closer_to_destination in H.
        destruct H.
        destruct H.
        specialize (H2 here).
        specialize (H2 current_flow.(Dest)).
        repeat rewrite Heqo in H2.
        simpl in H2.
        omega.
      + enough (~(In here path)) by tauto.
        apply paths_move_closer_to_destination in H.
        destruct H.
        eapply decreasing_costs_implies_nonmember with (costs := x); try eassumption.
        assert (H' := H).
        destruct H'.
        specialize (H4 here).
        specialize (H4 current_flow.(Dest)).
        rewrite Heqo in H4.
        destruct_with_eqn (paths n current_flow.(Dest)); try tauto.
        apply strictly_decreasing_costs_strengthening with (small_bound := path_cost x n l0); try omega.
        eapply all_pairs_paths_generate_strictly_decreasing_costs; eassumption.
  Qed.

  Definition all_pairs_paths_dec_next_node_generator
    (paths : all_pairs_paths)
    (topology : network_topology)
    (policy : network_policy)
    here
    current_flow
  :=
    if policy current_flow then
      match paths here current_flow.(Dest) with
      | Some (hop_target :: _) => Some hop_target
      | _ => None
      end
    else None.

  Lemma is_next_node_path_weakening : forall (strict_next lenient_next : next_node) path here current_flow,
    is_next_node_path strict_next path here current_flow
      -> (forall here' current_flow' hop_target, strict_next here' current_flow' hop_target -> lenient_next here' current_flow' hop_target)
      -> is_next_node_path lenient_next path here current_flow.
  Proof.
    intros.
    dependent induction path; simpl; simpl in H; try assumption.
    destruct H.
    assert (H0' := H0).
    apply IHpath with (here := a) (current_flow := current_flow) in H0; try tauto.
    constructor; try tauto.
    apply H0'; assumption.
  Qed.

  Lemma next_node_extensionality : forall next1 next2 topology policy,
    (forall here current_flow hop_target, next1 here current_flow hop_target <-> next2 here current_flow hop_target)
      -> next_node_valid topology policy next1
      -> next_node_valid topology policy next2.
  Proof.
    intros.
    constructor; intros; destruct H0.
    - eapply all_hops_in_topology0.
      apply H.
      eassumption.
    - constructor; intros.
      + apply path_exists_only_for_valid_flows0 in H0; try assumption.
        destruct H0.
        exists x.
        eapply is_next_node_path_weakening; try eassumption; apply H.
      + apply path_exists_only_for_valid_flows0.
        destruct H0.
        exists x.
        eapply is_next_node_path_weakening; try eassumption; apply H.
    - apply H in H1.
      apply no_black_holes0 in H1.
      destruct H1.
      exists x.
      eapply is_next_node_path_weakening; try eassumption; apply H.
    - eapply is_next_node_path_weakening in H1; try apply H.
      apply all_paths_acyclic0 in H1.
      assumption.
  Qed.

  Theorem all_pairs_paths_dec_generator_valid : forall paths topology policy,
    all_pairs_paths_valid topology policy paths
      -> dec_next_node_valid topology policy (all_pairs_paths_dec_next_node_generator paths topology policy).
  Proof.
    intros.
    apply all_pairs_paths_generator_valid in H.
    eapply next_node_extensionality; try eassumption.
    unfold all_pairs_paths_next_node_generator, all_pairs_paths_dec_next_node_generator.
    constructor; intros; repeat match goal with
    | [ H : _ /\ _ |- _ ] => destruct H
    | [ _ : _ |- _ /\ _ ] => constructor
    | [ H : context[match ?x with _ => _ end] |- _ ] => destruct x
    | [ H : ?x = _ |- context[?x] ] => rewrite H
    | [ H : _ ?a = _ ?b |- ?b = ?a ] => injection H; apply eq_sym
    | _ => tauto
    | _ => discriminate
    end.
  Qed.

  Definition routing_tables := Node -> list (flow * Node).

  Record routing_tables_valid (tables : routing_tables) (dec_next : dec_next_node) := {
    no_duplicate_entries : forall here,
      NoDup (tables here);

    entries_match_next_node_result : forall here current_flow hop_target,
      dec_next here current_flow = Some hop_target
        <-> In (current_flow, hop_target) (tables here)
  }.

  Definition routing_tables_generator := dec_next_node -> list Node -> routing_tables.

  Definition routing_tables_generator_valid (generator : routing_tables_generator) := forall dec_next all_nodes,
    Listing all_nodes
      -> routing_tables_valid
        (generator dec_next all_nodes)
        dec_next.

  Fixpoint map_filter {A} {B} (mapper : A -> option B) (l : list A) :=
    match l with
    | [] => []
    | car :: cdr =>
      match mapper car with
      | Some car' => car' :: map_filter mapper cdr
      | None => map_filter mapper cdr
      end
    end.

  Lemma map_filter_in_preservation : forall A B mapper l (element : A) (result : B),
    (forall (x y : A), {x = y} + {x <> y})
      -> mapper element = Some result
      -> In element l
      -> In result (map_filter mapper l).
  Proof.
    intros.
    dependent induction l; try (simpl in H0; tauto).
    assert ({a = element} + {a <> element}) by apply X.
    destruct H1.
    - subst.
      simpl.
      rewrite H.
      constructor.
      reflexivity.
    - simpl.
      assert (In result (map_filter mapper l)).
      + simpl in H0.
        destruct H0; try tauto.
        eapply IHl; eassumption.
      + destruct (mapper a); simpl; tauto.
  Qed.

  Lemma map_filter_in_filtering : forall A B mapper l (result : B),
    (forall (x y : B), {x = y} + {x <> y})
      -> In result (map_filter mapper l)
      -> {element : A | mapper element = Some result}.
  Proof.
    intros.
    dependent induction l; try (simpl in H; tauto).
    simpl in H.
    destruct_with_eqn (mapper a).
    - assert ({b = result} + {b <> result}) by apply X.
      destruct H0.
      + subst.
        apply exist with (x := a).
        assumption.
      + simpl in H.
        apply IHl; try assumption.
        destruct H; tauto.
    - apply IHl; assumption.
  Qed.

  Definition fst {A} {B} (pair : A * B) := match pair with | (l, _) => l end.
  Definition snd {A} {B} (pair : A * B) := match pair with | (_, r) => r end.

  Hypothesis Node_eq_dec : forall x y : Node, {x = y} + {x <> y}.
  Definition Node_pair_eq_dec : forall x y : (Node * Node), {x = y} + {x <> y}.
  Proof.
    intros.
    destruct x, y, Node_eq_dec with (x := n) (y := n1), Node_eq_dec with (x := n0) (y := n2); subst; try (constructor 1; reflexivity); constructor 2; congruence.
  Defined.

  Definition flow_Node_pair_eq_dec : forall x y : (flow * Node), {x = y} + {x <> y}.
  Proof.
    intros.
    destruct x, y, f, f0, Node_eq_dec with (x := Src0) (y := Src1), Node_eq_dec with (x := Dest0) (y := Dest1), Node_eq_dec with (x := n) (y := n0); subst; try (constructor 1; reflexivity); constructor 2; congruence.
  Defined.

  Definition flow_eq_dec : forall x y : flow, {x = y} + {x.(Src) <> y.(Src)} + {x.(Dest) <> y.(Dest)}.
  Proof.
    intros.
    destruct x, y, Node_eq_dec with (x := Src0) (y := Src1), Node_eq_dec with (x := Dest0) (y := Dest1); subst.
    - constructor 1; constructor 1; reflexivity.
    - constructor 2; simpl; tauto.
    - constructor 1; constructor 2; simpl; tauto.
    - constructor 2; simpl; tauto.
  Defined.

  Definition exhaustive_routing_tables_generator (dec_next : dec_next_node) (all_nodes : list Node) (here : Node) :=
    map_filter (fun pair =>
      match dec_next here {| Src := fst pair; Dest := snd pair |} with
      | Some hop_target => Some ({| Src := fst pair; Dest := snd pair |}, hop_target)
      | None => None
      end
    ) (nodup Node_pair_eq_dec (list_prod all_nodes all_nodes)).

  Theorem exhaustive_routing_tables_generator_valid : routing_tables_generator_valid exhaustive_routing_tables_generator.
  Proof.
    unfold exhaustive_routing_tables_generator.
    constructor; intros.
    - remember (nodup Node_pair_eq_dec (list_prod all_nodes all_nodes)) as pairs.
      assert (NoDup pairs) by (subst; apply NoDup_nodup).
      clear H Heqpairs.
      dependent induction pairs; try apply NoDup_nil.
      simpl.
      inversion_clear H0; subst.
      destruct a; simpl.
      destruct (dec_next here {| Src := n; Dest := n0 |}); try (apply IHpairs; assumption).
      constructor; try (apply IHpairs; assumption).
      clear IHpairs.
      dependent induction pairs; try (simpl; tauto).
      inversion_clear H1; subst.
      simpl.
      destruct (dec_next here {| Src := fst a; Dest := snd a |}).
      + simpl.
        unfold not.
        intros.
        destruct a.
        destruct H1.
        * injection H1.
          intros.
          subst.
          apply H0.
          simpl in H.
          tauto.
        * apply IHpairs in H1; try assumption.
          simpl in H.
          tauto.
      + simpl in H.
        apply IHpairs; tauto.
    - constructor; intros.
      + apply map_filter_in_preservation with (element := (current_flow.(Src), current_flow.(Dest))).
        * apply Node_pair_eq_dec.
        * destruct current_flow.
          simpl.
          rewrite H0.
          reflexivity.
        * apply nodup_In, in_prod; apply H.
      + apply map_filter_in_filtering in H0; try apply flow_Node_pair_eq_dec.
        destruct H0.
        assert (x = (current_flow.(Src), current_flow.(Dest))).
        * destruct (dec_next here {| Src := fst x; Dest := snd x |}); try discriminate.
          injection e.
          intros.
          subst.
          destruct x.
          simpl.
          reflexivity.
        * subst.
          destruct current_flow.
          simpl in e.
          destruct (dec_next here {| Src := Src0; Dest := Dest0 |}); try discriminate.
          congruence.
  Qed.

  (* TODO: Figure out how to import some of this from a separate file *)
  Section OpenFlow.
    Definition ipv4_address : Type := word 8 * word 8 * word 8 * word 8.

    Definition ipv4_eqb (ip1 ip2 : ipv4_address) : bool :=
      match ip1, ip2 with
      | (a1, b1, c1, d1), (a2, b2, c2, d2) => weqb a1 a2 && weqb b1 b2 && weqb c1 c2 && weqb d1 d2
      end.

    Lemma ipv4_eqb_iff : forall ip1 ip2, ipv4_eqb ip1 ip2 = true <-> ip1 = ip2.
    Proof.
      intros; constructor.
      - intros; unfold ipv4_eqb in H; repeat match goal with
        | [ H : context[let (_, _) := ?i in _] |- _ ] => destruct i
        | [ H : (_ && _)%bool = true |- _ ] => unfold andb in H
        | [ H : (if ?e then ?f else false) = true |- _ ] => assert (e = true) by (destruct e; [reflexivity | discriminate]); assert (f = true) by (destruct e; [assumption | discriminate]); clear H
        | [ H : weqb ?a ?b = true |- _ ] => apply weqb_true_iff in H
        end; subst; reflexivity.
      - intros; unfold ipv4_eqb; repeat match goal with
        | [ |- context[let (_, _) := ?i in _] ] => destruct i
        | [ |- (_ && _)%bool = true ] => unfold andb
        | [ |- weqb ?w ?w = true ] => apply weqb_true_iff; reflexivity
        | [ H : weqb ?w ?w = true |- context[if weqb ?w ?w then _ else _] ] => rewrite H
        | [ |- context[if weqb ?w ?w then _ else _] ] => assert (weqb w w = true)
        | [ H : (?a, ?b, ?c, ?d) = (?e, ?f, ?g, ?h) |- _ ] => injection H; clear H; intros; subst
        end.
    Qed.

    Lemma ipv4_eqb_refl : forall ip, ipv4_eqb ip ip = true.
    Proof.
      intros.
      apply ipv4_eqb_iff.
      reflexivity.
    Qed.

    Record ipv4_packet := {
      IpSrc : ipv4_address;
      IpDest : ipv4_address
      (* Other fields exist but are not used here *)
    }.


    (* OpenFlow switch spec: https://www.opennetworking.org/wp-content/uploads/2013/04/openflow-spec-v1.0.0.pdf *)

    Record header_fields_matcher := {
      (* TODO: support IP wildcard matchers *)
      IpSrcMatcher : option ipv4_address;
      IpDestMatcher : option ipv4_address
      (* Other header fields exist but are not used here *)
    }.

    Inductive openflow_action :=
    | ForwardToPort : Port -> openflow_action
    | Drop
    (* Other actions exist but are not used here *)
    .

    Record openflow_flow_entry := {
      header_fields : header_fields_matcher;
      action : openflow_action (* This can actually be a list of actions, but only one is used here *)
      (* Entries also contain "counters" which are not used here *)
    }.

    Definition matches_header_fields_matcher (packet : ipv4_packet) (matcher : header_fields_matcher) : bool :=
      match matcher.(IpSrcMatcher) with
      | Some src_address => ipv4_eqb src_address packet.(IpSrc)
      | None => true
      end &&
      match matcher.(IpDestMatcher) with
      | Some dest_address => ipv4_eqb dest_address packet.(IpDest)
      | None => true
      end.

    Fixpoint get_matching_action packet openflow_flow_entries :=
      match openflow_flow_entries with
      | [] => Drop
      | entry :: cdr =>
        if matches_header_fields_matcher packet entry.(header_fields)
        then entry.(action)
        else get_matching_action packet cdr
      end.

    Definition node_ip_map := Node -> ipv4_address.
    Definition node_openflow_entry_map := Node -> list openflow_flow_entry.

    Inductive openflow_network_packet_state :=
    | EnRoute : node_ip_map -> node_openflow_entry_map -> network_topology -> ipv4_packet -> Node -> openflow_network_packet_state
    | Arrived
    | Dropped
    .

    Inductive openflow_network_step : openflow_network_packet_state -> openflow_network_packet_state -> Prop :=
    | ForwardPacket : forall node_ips entries ports port packet location new_location,
      get_matching_action packet (entries location) = ForwardToPort port
        -> ports location new_location = Some port
        -> ipv4_eqb (node_ips location) packet.(IpDest) = false
        -> openflow_network_step (EnRoute node_ips entries ports packet location) (EnRoute node_ips entries ports packet new_location)
    | DropPacket : forall node_ips entries ports packet location,
      get_matching_action packet (entries location) = Drop
        -> ipv4_eqb (node_ips location) packet.(IpDest) = false
        -> openflow_network_step (EnRoute node_ips entries ports packet location) Dropped
    | ReceivePacket : forall node_ips entries ports packet location,
      ipv4_eqb (node_ips location) packet.(IpDest) = true
        -> openflow_network_step (EnRoute node_ips entries ports packet location) Arrived
    .

    Definition generate_openflow_entries
      (tables : routing_tables)
      (node_ips : node_ip_map)
      (topology : network_topology)
      node
    :=
      map (fun pair => {|
        header_fields := {|
          IpSrcMatcher := Some (node_ips pair.(fst).(Src));
          IpDestMatcher := Some (node_ips pair.(fst).(Dest))
        |};
        action := match topology node pair.(snd) with
        | Some port => ForwardToPort port

        (* Impossible if `tables` is valid for the topology *)
        | None => Drop
        end
      |}) (tables node).

    Fixpoint all_ports_exist (topology : network_topology) node openflow_flow_entries :=
      match openflow_flow_entries with
      | [] => True
      | entry :: cdr =>
        match entry.(action) with
        | ForwardToPort port => exists hop_target, topology node hop_target = Some port
        | Drop => True
        end /\ all_ports_exist topology node cdr
      end.

    Fixpoint always_reaches_state_after_bounded_steps desired_state num_steps current_state : Prop :=
      desired_state = current_state \/
      match num_steps with
      | 0 => False
      | S num_steps' =>
        (exists new_state, openflow_network_step current_state new_state) /\
        forall new_state,
          openflow_network_step current_state new_state
            -> always_reaches_state_after_bounded_steps desired_state num_steps' new_state
      end.

    Definition should_arrive (policy : network_policy) src dest :=
      if policy {| Src := src; Dest := dest |}
      then true
      else if Node_eq_dec src dest
        then true
        else false.

    Record valid_openflow_entries (topology : network_topology) (policy : network_policy) (node_ips : node_ip_map) (entry_map : node_openflow_entry_map) : Prop := {
      packets_arrive_iff_allowed : forall packet src_node dest_node,
        node_ips src_node = packet.(IpSrc)
          -> node_ips dest_node = packet.(IpDest)
          -> exists num_steps,

            (* Note: If the source/dest node have the same IP (or are the same node), this will always be true if num_steps >= 1 *)
            always_reaches_state_after_bounded_steps
              (if should_arrive policy src_node dest_node then Arrived else Dropped)
              num_steps
              (EnRoute node_ips entry_map topology packet src_node);
      existent_ports : forall node, all_ports_exist topology node (entry_map node)
    }.

    Lemma get_matching_action_forwards_to_correct_port : forall topology dec_next current_flow here hop_target port node_ips all_nodes,
      dec_next here current_flow = Some hop_target
        -> topology here hop_target = Some port
        -> Injective node_ips
        -> Listing all_nodes
        -> routing_tables_valid (exhaustive_routing_tables_generator dec_next all_nodes) dec_next
        -> get_matching_action
          {| IpSrc := node_ips current_flow.(Src); IpDest := node_ips current_flow.(Dest) |}
          (generate_openflow_entries (exhaustive_routing_tables_generator dec_next all_nodes) node_ips topology here)
          = ForwardToPort port.
    Proof.
      intros.
      assert (forall hop, dec_next here current_flow = Some hop <-> In (current_flow, hop) (exhaustive_routing_tables_generator dec_next all_nodes here)) by (intros; apply entries_match_next_node_result; assumption).
      clear H3.
      unfold generate_openflow_entries.
      induction (exhaustive_routing_tables_generator dec_next all_nodes here); [ apply H4 in H; inversion H | idtac ].
      simpl.
      destruct a.
      assert ({current_flow = f} + {current_flow.(Src) <> f.(Src)} + {current_flow.(Dest) <> f.(Dest)}) by (apply flow_eq_dec).
      destruct H3; [ destruct s | idtac ].
      - destruct current_flow, f; injection e; intros; subst; simpl.
        unfold matches_header_fields_matcher.
        simpl.
        repeat rewrite ipv4_eqb_refl.
        simpl.
        enough (hop_target = n) by (rewrite <- H3, H0; reflexivity).
        enough (Some hop_target = Some n) by (injection H3; tauto).
        rewrite <- H.
        apply H4.
        constructor.
        reflexivity.
      - unfold matches_header_fields_matcher.
        simpl.
        destruct_with_eqn (ipv4_eqb (node_ips f.(Src)) (node_ips current_flow.(Src))); [ apply ipv4_eqb_iff, H1, eq_sym in Heqb; tauto | idtac ].
        simpl.
        apply IHl.
        intros.
        constructor; intros; try (apply H4; constructor 2; assumption).
        apply H4 in H3.
        inversion_clear H3; try assumption.
        congruence.
      - unfold matches_header_fields_matcher.
        simpl.
        destruct_with_eqn (ipv4_eqb (node_ips f.(Dest)) (node_ips current_flow.(Dest))); [ apply ipv4_eqb_iff, H1, eq_sym in Heqb; tauto | idtac ].
        rewrite andb_false_r.
        (* FIXME: the lines below here are duplicated from the above subgoal *)
        apply IHl.
        intros.
        constructor; intros; try (apply H4; constructor 2; assumption).
        apply H4 in H3.
        inversion_clear H3; try assumption.
        congruence.
    Qed.

    Lemma get_matching_action_drops : forall topology dec_next current_flow here node_ips all_nodes,
      dec_next here current_flow = None
        -> Injective node_ips
        -> Listing all_nodes
        -> routing_tables_valid (exhaustive_routing_tables_generator dec_next all_nodes) dec_next
        -> get_matching_action
          {| IpSrc := node_ips current_flow.(Src); IpDest := node_ips current_flow.(Dest) |}
          (generate_openflow_entries (exhaustive_routing_tables_generator dec_next all_nodes) node_ips topology here)
          = Drop.
    Proof.
      intros.
      assert (forall hop, dec_next here current_flow = Some hop <-> In (current_flow, hop) (exhaustive_routing_tables_generator dec_next all_nodes here)) by (intros; apply entries_match_next_node_result; assumption).
      clear H2.
      unfold generate_openflow_entries.
      induction (exhaustive_routing_tables_generator dec_next all_nodes here); try reflexivity.
      simpl.
      unfold matches_header_fields_matcher.
      destruct a.
      simpl.
      assert ({current_flow = f} + {current_flow.(Src) <> f.(Src)} + {current_flow.(Dest) <> f.(Dest)}) by (apply flow_eq_dec).
      destruct H2; [ destruct s | idtac ].
      - subst.
        assert (dec_next here f = Some n) by (apply H3; simpl; tauto).
        rewrite H2 in H.
        discriminate.
      (* TODO: combine this proof with `get_matching_action_forwards_to_correct_port`
        and extract duplicated portions into an ltac script *)
      - destruct_with_eqn (ipv4_eqb (node_ips f.(Src)) (node_ips current_flow.(Src))); [ apply ipv4_eqb_iff, H0, eq_sym in Heqb; tauto | idtac ].
        apply IHl.
        intros.
        constructor; intros; try (apply H3; constructor 2; assumption).
        apply H3 in H2.
        inversion_clear H2; try assumption.
        congruence.
      - destruct_with_eqn (ipv4_eqb (node_ips f.(Dest)) (node_ips current_flow.(Dest))); [ apply ipv4_eqb_iff, H0, eq_sym in Heqb; tauto | idtac ].
        rewrite andb_false_r.
        apply IHl.
        intros.
        constructor; intros; try (apply H3; constructor 2; assumption).
        apply H3 in H2.
        inversion_clear H2; try assumption.
        congruence.
    Qed.

    Lemma dec_next_creates_valid_unique_state_transitions : forall topology policy dec_next node_ips (packet : ipv4_packet) here current_flow all_nodes openflow_entries,
      dec_next_node_valid topology policy dec_next
        -> valid_topology topology
        -> Listing all_nodes
        -> Injective node_ips
        -> openflow_entries = generate_openflow_entries (exhaustive_routing_tables_generator dec_next all_nodes) node_ips topology
        -> packet = {| IpSrc := node_ips current_flow.(Src); IpDest := node_ips current_flow.(Dest) |}
        -> here <> current_flow.(Dest)
        -> (
          (exists new_state, openflow_network_step (EnRoute node_ips openflow_entries topology packet here) new_state) /\
          forall new_state,
            openflow_network_step (EnRoute node_ips openflow_entries topology packet here) new_state
              -> new_state =
                  match dec_next here current_flow with
                  | Some hop_target => EnRoute node_ips openflow_entries topology packet hop_target
                  | None => Dropped
                  end
        ).
    Proof.
      intros.
      assert (routing_tables_valid (exhaustive_routing_tables_generator dec_next all_nodes) dec_next) by (apply exhaustive_routing_tables_generator_valid; assumption).
      constructor; destruct_with_eqn (dec_next here current_flow).
      - exists (EnRoute node_ips openflow_entries topology packet n).
        apply all_hops_in_topology with (topology := topology) (policy := policy) (here := here) (hop_target := n) (current_flow := current_flow) in H; try assumption.
        destruct_with_eqn (topology here n); try tauto.
        apply ForwardPacket with (port := p); try assumption.
        + subst.
          apply get_matching_action_forwards_to_correct_port with (hop_target := n); assumption.
        + rewrite H4.
          simpl.
          destruct_with_eqn (ipv4_eqb (node_ips here) (node_ips current_flow.(Dest))); try reflexivity.
          apply ipv4_eqb_iff, H2 in Heqb; tauto.
      - exists Dropped.
        subst.
        constructor; simpl; try (apply get_matching_action_drops; assumption).
        destruct_with_eqn (ipv4_eqb (node_ips here) (node_ips current_flow.(Dest))); try reflexivity.
        apply ipv4_eqb_iff, H2 in Heqb; tauto.
      - intros.
        inversion_clear H7; subst.
        + apply all_hops_in_topology with (topology := topology) (policy := policy) (here := here) (hop_target := n) (current_flow := current_flow) in H; try assumption.
          destruct_with_eqn (topology here n); try tauto.
          assert (
            get_matching_action
              {| IpSrc := node_ips current_flow.(Src); IpDest := node_ips current_flow.(Dest) |}
              (generate_openflow_entries (exhaustive_routing_tables_generator dec_next all_nodes) node_ips topology here)
            = ForwardToPort p
          ) by (apply get_matching_action_forwards_to_correct_port with (hop_target := n); assumption).
          rewrite H3 in H8.
          injection H8; intros; subst.
          enough (n = new_location) by (subst; reflexivity).
          specialize (H0 here).
          specialize (H0 n).
          specialize (H0 new_location).
          rewrite Heqo0, H9 in H0.
          apply H0.
          reflexivity.
        + apply all_hops_in_topology with (topology := topology) (policy := policy) (here := here) (hop_target := n) (current_flow := current_flow) in H; try assumption.
          destruct_with_eqn (topology here n); try tauto.
          assert (
            get_matching_action
              {| IpSrc := node_ips current_flow.(Src); IpDest := node_ips current_flow.(Dest) |}
              (generate_openflow_entries (exhaustive_routing_tables_generator dec_next all_nodes) node_ips topology here)
            = ForwardToPort p
          ) by (apply get_matching_action_forwards_to_correct_port with (hop_target := n); assumption).
          rewrite H3 in H8.
          discriminate.
        + apply ipv4_eqb_iff, H2 in H8; tauto.
      - intros.
        inversion_clear H7; subst; try reflexivity.
        + assert (
            get_matching_action
              {| IpSrc := node_ips current_flow.(Src); IpDest := node_ips current_flow.(Dest) |}
              (generate_openflow_entries (exhaustive_routing_tables_generator dec_next all_nodes) node_ips topology here)
            = Drop
          ) by (apply get_matching_action_drops; assumption).
          rewrite H3 in H8.
          discriminate.
        + apply ipv4_eqb_iff, H2 in H8.
          tauto.
    Qed.

    Lemma reaches_arrived_state_from_destination_in_one_step : forall node_ips entries topology src_node dest_node,
      always_reaches_state_after_bounded_steps Arrived 1 (EnRoute node_ips entries topology {| IpSrc := node_ips src_node; IpDest := node_ips dest_node |} dest_node).
    Proof.
      intros.
      simpl.
      apply or_intror.
      constructor.
      - exists Arrived.
        constructor.
        simpl.
        apply ipv4_eqb_refl.
      - intros.
        apply or_introl.
        inversion_clear H; try reflexivity; subst; repeat match goal with
        | [ H : context[IpDest {| IpSrc := _; IpDest := _ |}] |- _ ] => simpl in H
        | [ H : ipv4_eqb ?x ?x = false |- _ ] => rewrite ipv4_eqb_refl in H; discriminate
        end.
    Qed.

    Lemma always_reaches_state_after_bounded_steps_weakening : forall desired_state big_num_steps small_num_steps current_state,
      always_reaches_state_after_bounded_steps desired_state small_num_steps current_state
        -> small_num_steps <= big_num_steps
        -> always_reaches_state_after_bounded_steps desired_state big_num_steps current_state.
    Proof.
      intros.
      dependent induction small_num_steps generalizing big_num_steps.
      - simpl in H.
        destruct H; try tauto.
        destruct big_num_steps; simpl; tauto.
      - destruct big_num_steps; try omega.
        simpl.
        destruct H; [ apply or_introl | apply or_intror ]; try assumption.
        destruct H.
        constructor; try assumption.
        intros.
        apply IHsmall_num_steps.
        + apply H1; assumption.
        + omega.
    Qed.

    Lemma disallowed_flow_immediately_dropped : forall topology policy next src dest hop_target,
      next_node_valid topology policy next
        -> policy {| Src := src; Dest := dest |} = false
        -> ~next src {| Src := src; Dest := dest |} hop_target.
    Proof.
      unfold not.
      intros.
      assert (H' := H).
      assert (H'' := H).
      apply path_exists_only_for_valid_flows with (current_flow := {| Src := src; Dest := dest |}) in H.
      simpl in H.
      apply no_black_holes with (topology := topology) (policy := policy) (current_flow := {| Src := src; Dest := dest |}) (here := src) (hop_target := hop_target) in H'; try assumption.
      destruct H'.
      assert (exists path, is_next_node_path next path src {| Src := src; Dest := dest |}) by (exists (hop_target :: x); constructor; tauto).
      apply H in H3.
      destruct H3.
      - rewrite H0 in H3.
        discriminate.
      - subst.
        apply all_paths_acyclic with (path := (hop_target :: x)) (here := dest) (current_flow := {| Src := dest; Dest := dest |}) in H''; try (constructor; assumption).
        clear H0 H H1.
        dependent induction x generalizing hop_target.
        + simpl in H2.
          subst.
          inversion_clear H''.
          apply H.
          constructor.
          reflexivity.
        + apply IHx with (hop_target := a); try (simpl in H2; tauto).
          inversion_clear H''; subst.
          inversion_clear H0; subst.
          constructor; try assumption.
          simpl.
          simpl in H.
          tauto.
    Qed.

    Lemma disallowed_packet_eventually_dropped : forall topology policy dec_next all_nodes node_ips src dest,
      valid_topology topology
        -> Listing all_nodes
        -> Injective node_ips
        -> dec_next_node_valid topology policy dec_next
        -> policy {| Src := src; Dest := dest |} = false
        -> src <> dest
        -> exists num_steps,
          always_reaches_state_after_bounded_steps Dropped num_steps (
            EnRoute node_ips
              (
                generate_openflow_entries
                  (exhaustive_routing_tables_generator dec_next all_nodes)
                  node_ips
                  topology
              )
              topology
              {| IpSrc := node_ips src; IpDest := node_ips dest |}
              src
          ).
    Proof.
      intros.
      (* Currently, the definition of validity requires disallowed
         packets to be *immediately* dropped, which simplifies
         this proof. *)
      exists 1.
      assert (dec_next src {| Src := src; Dest := dest |} = None).
      - destruct_with_eqn (dec_next src {| Src := src; Dest := dest |}); try reflexivity.
        apply disallowed_flow_immediately_dropped with (src := src) (dest := dest) (hop_target := n) in H2; tauto.
      - simpl.
        apply or_intror.
        eapply dec_next_creates_valid_unique_state_transitions with (current_flow := {| Src := src; Dest := dest |}) in H2; try eassumption; try reflexivity.
        simpl in H2.
        constructor; try tauto.
        intros.
        apply or_introl, eq_sym.
        destruct H2.
        eassert (Dropped = match dec_next src _ with | Some _ => _ | None => Dropped end) by (rewrite H5; reflexivity).
        rewrite H8.
        apply H7.
        assumption.
    Qed.

    Theorem openflow_rules_generator_validity : forall topology policy paths all_nodes node_ips,
      valid_topology topology
        -> all_pairs_paths_valid topology policy paths
        -> Listing all_nodes
        -> Injective node_ips
        -> valid_openflow_entries
          topology
          policy
          node_ips
          (
            generate_openflow_entries
            (
              exhaustive_routing_tables_generator
              (all_pairs_paths_dec_next_node_generator paths topology policy)
              all_nodes
            )
            node_ips
            topology
          ).
    Proof.
      intros.
      set (dec_next := all_pairs_paths_dec_next_node_generator paths topology policy).
      set (tables := exhaustive_routing_tables_generator dec_next all_nodes).
      set (openflow_entries := generate_openflow_entries tables node_ips topology).
      assert (dec_next_node_valid topology policy dec_next) by (apply all_pairs_paths_dec_generator_valid; assumption).
      assert (routing_tables_valid tables dec_next) by (apply exhaustive_routing_tables_generator_valid; assumption).
      constructor; intros.
      - unfold dec_next_node_valid in H3.
        assert (dec_next_node_valid topology policy dec_next) by (apply all_pairs_paths_dec_generator_valid; assumption).
        assert (H' := H7).
        apply path_exists_only_for_valid_flows with (current_flow := {| Src := src_node; Dest := dest_node |}) in H7; try (simpl; assumption).
        simpl in H7.
        assert ((policy {| Src := src_node; Dest := dest_node |} = true \/ src_node = dest_node) <-> should_arrive policy src_node dest_node = true). {
          unfold should_arrive.
          repeat match goal with
          | [ |- context[if ?x then _ else _] ] => destruct x
          | _ => tauto
          end.
        }
        rewrite H8 in H7.
        clear H8.
        destruct_with_eqn (should_arrive policy src_node dest_node).
        + clear Heqb.
          assert (exists path, _) by (apply H7; reflexivity).
          clear H7.
          destruct H8.
          exists (S (length x)).
          remember {| Src := src_node; Dest := dest_node |} as flow.
          assert (node_ips flow.(Src) = IpSrc packet) by (rewrite <- H5, Heqflow; tauto).
          assert (node_ips flow.(Dest) = IpDest packet) by (rewrite <- H6, Heqflow; tauto).
          clear H5 H6 Heqflow.
          destruct packet.
          simpl in H8, H9.
          subst.
          dependent induction x generalizing src_node; try (simpl in H7; subst; apply reaches_arrived_state_from_destination_in_one_step).
          assert ({src_node = flow0.(Dest)} + {src_node <> flow0.(Dest)}) by (apply Node_eq_dec).
          destruct H5.
          * subst.
            apply always_reaches_state_after_bounded_steps_weakening with (small_num_steps := 1); try omega.
            apply reaches_arrived_state_from_destination_in_one_step.
          * destruct H7.
            apply IHx in H6; try assumption.
            remember (a :: x) as path.
            assert (S (length x) = length path) by (rewrite Heqpath; simpl; reflexivity).
            rewrite H7 in H6.
            clear Heqpath H7.
            simpl.
            apply or_intror.
            remember (length path) as remaining_steps; clear Heqremaining_steps path.
            eassert (_ /\ _) by (apply dec_next_creates_valid_unique_state_transitions with (policy := policy) (dec_next := dec_next) (current_flow := flow0) (all_nodes := all_nodes) (openflow_entries := openflow_entries); try eassumption; eauto).
            destruct H7.
            constructor; try assumption.
            intros.
            apply H8 in H9.
            subst.
            rewrite H5.
            assumption.
        + unfold should_arrive in Heqb.
          assert (policy {| Src := src_node; Dest := dest_node |} = false) by (destruct (policy {| Src := src_node; Dest := dest_node |}); firstorder discriminate).
          assert (src_node <> dest_node) by (destruct (Node_eq_dec src_node dest_node), (policy {| Src := src_node; Dest := dest_node |}); try discriminate; assumption).
          clear Heqb H7.
          destruct packet.
          unfold openflow_entries, tables.
          simpl in H5, H6.
          rewrite <- H5, <- H6.
          eapply disallowed_packet_eventually_dropped; eassumption.
      - unfold openflow_entries, generate_openflow_entries.
        set (node_tables := tables node).
        dependent induction node_tables; simpl; try tauto.
        constructor; try assumption.
        destruct_with_eqn (topology node a.(snd)); try tauto.
        eexists; eassumption.
    Qed.

    Definition openflow_rules_generator
      (topology : {t : network_topology | valid_topology t})
      policy
      (paths : {pairs_paths : all_pairs_paths | all_pairs_paths_valid (proj1_sig topology) policy pairs_paths})
      (all_nodes : {enumeration : list Node | Listing enumeration})
      (node_ips : {ips : node_ip_map | Injective ips})
    : {entries : node_openflow_entry_map | valid_openflow_entries (proj1_sig topology) policy (proj1_sig node_ips) entries}.
    Proof.
      econstructor.
      apply openflow_rules_generator_validity with (paths := proj1_sig paths) (all_nodes := proj1_sig all_nodes); exact (proj2_sig _).
    Defined.
  End OpenFlow.
End Node.

Ltac prove_decidable_equality :=
  let Node := match goal with
  | [ |- forall x y : ?Node, {x = y} + {x <> y} ] => Node
  | _ => fail 1 "Unexpected goal in decidable equality proof"
  end in
  intros;
  repeat match goal with
  | [ x : Node |- _ ] => destruct x
  end;
  firstorder discriminate.

Ltac prove_valid_topology topology :=
  let Node := match goal with
  | [ |- {t : network_topology ?Node | valid_topology ?Node t} ] => Node
  | _ => fail 1 "Unexpected goal in valid topology proof"
  end in
  apply exist with (x := topology);
  unfold valid_topology;
  intros;
  repeat match goal with
  | [ x : Node |- _ ] => destruct x
  end;
  simpl;
  try reflexivity;
  try discriminate.

Ltac prove_injective_ips node_ips :=
  let Node := match goal with
  | [ |- {ips : node_ip_map ?Node | Injective ips} ] => Node
  | _ => fail 1 "Unexpected goal in injective IPs proof"
  end in
  apply exist with (x := node_ips);
  unfold Injective;
  intros;
  repeat match goal with
  | [ x : Node |- _ ] => destruct x
  end;
  try reflexivity;
  try discriminate.

Ltac enumerate_finite_set :=
  let Node := match goal with
  | [ |- {l : list ?Node | Listing l} ] => Node
  | _ => fail 1 "Unexpected goal in finite set enumeration"
  end in
  econstructor;
  unfold Listing, Full;
  constructor;
  [
    idtac |
    intros;
    match goal with
    | [ node : Node |- _ ] => destruct node
    end;
    unshelve (
      let cdr := fresh "cdr" in
        evar (cdr : list Node);
        let cdr' := (eval unfold cdr in cdr) in
          clear cdr;
          match goal with
          | [ |- In ?n _ ] => instantiate (1 := n :: cdr')
          end;
          simpl;
          tauto
    );
    exact []
  ];
  repeat constructor;
  firstorder discriminate.

Section NetworkExample.
  Local Inductive ExampleVertex :=
  | A
  | B
  | C
  | D
  | E
  | F
  .

  (*
    example_topology:

        B ------> E
      / | \       
     A  |5 D <--- F
      \ | /
        C
  *)
  Local Definition example_topology n1 n2 :=
    match n1, n2 with
    (* Arbitrarily, the ports are numbered in increasing
       order at each node. *)
    | A, B => Some (natToWord 16 0)
    | B, A => Some (natToWord 16 0)
    | A, C => Some (natToWord 16 1)
    | C, A => Some (natToWord 16 0)
    | B, C => Some (natToWord 16 1)
    | C, B => Some (natToWord 16 1)
    | B, D => Some (natToWord 16 2)
    | D, B => Some (natToWord 16 0)
    | B, E => Some (natToWord 16 3)
    | C, D => Some (natToWord 16 2)
    | D, C => Some (natToWord 16 1)
    | F, D => Some (natToWord 16 0)
    | F, E => Some (natToWord 16 1)
    | _, _ => None
    end.

  Local Definition example_all_pairs_paths n1 n2 :=
    match n1, n2 with
    | A, A | B, B | C, C | D, D | E, E | F, F => Some []
    | A, B => Some [C; B]
    | A, C => Some [C]
    | A, D => Some [B; D]
    | A, E => Some [B; E]
    | A, F => None
    | B, A => Some [A]
    | B, C => Some [C]
    | B, D => Some [D]
    | B, E => Some [E]
    | B, F => None
    | C, A => Some [A]
    | C, B => Some [B]
    | C, D => Some [D]
    | C, E => Some [A; B; E]
    | C, F => None
    | D, A => Some [C; A]
    | D, B => Some [B]
    | D, C => Some [C]
    | D, E => Some [C; A; B; E]
    | D, F => None
    | E, _ => None
    | F, A => Some [D; B; A]
    | F, B => Some [D; B]
    | F, C => Some [D; C]
    | F, D => Some [D]

    (* a route which won't actually get followed because D will reroute *)
    | F, E => Some [D; C; B; E]
    end.

  (* Giving all edges a cost of 1 would not satisfy the decreasing-costs
  constraint, because when routing F to E, node B would choose
  a path of [C; A; B; E] which is not shorter than the original expected
  path from F of [D; C; B; E]. However, if the (C, B) edge
  has a large cost, then the total cost of [C; A; B; E] is less
  than the cost of [D; C; B; E]. *)
  Definition example_costs n1 n2 :=
    match n1, n2 with
    | C, B => 5
    | _, _ => 1
    end.

  Definition policy_satisfiable (policy : network_policy ExampleVertex) := forall n1 n2,
    policy {| Src := n1; Dest := n2 |} = true -> example_all_pairs_paths n1 n2 <> None.

  Local Lemma example_paths_valid : forall policy,
    policy_satisfiable policy
      -> all_pairs_paths_valid ExampleVertex example_topology policy example_all_pairs_paths.
  Proof.
    intros.
    constructor; intros.
    - destruct src, dest; unfold example_topology; simpl; tauto.
    - destruct current_flow.
      simpl.
      apply H in H0.
      destruct (example_all_pairs_paths Src0 Dest0); tauto.
    - exists example_costs.
      constructor; try (unfold only_positive_costs, example_costs; intros; destruct n1, n2; omega).
      intros.
      destruct src, dest; simpl; try omega; tauto.
  Qed.

  Local Definition example_policy current_flow :=
    match Src ExampleVertex current_flow, Dest ExampleVertex current_flow with
    | A, F | E, A => false
    | A, _ | _, A | F, _ => true
    | _, _ => false
    end.

  Definition example_node_ips_nat node :=
    match node with
    | A => (10, 0, 0, 1)
    | B => (10, 0, 0, 2)
    | C => (10, 0, 0, 3)
    | D => (10, 0, 0, 4)
    | E => (10, 0, 0, 5)
    | F => (10, 0, 0, 6)
    end.

  Definition example_node_ips node :=
    match example_node_ips_nat node with
    | (n1, n2, n3, n4) => (natToWord 8 n1, natToWord 8 n2, natToWord 8 n3, natToWord 8 n4)
    end.


  Definition example_all_pairs_paths_valid : all_pairs_paths_valid ExampleVertex example_topology example_policy example_all_pairs_paths.
  Proof.
    apply example_paths_valid.
    unfold policy_satisfiable.
    intros.
    destruct n1, n2; discriminate.
  Qed.

  Definition all_nodes : {l : list ExampleVertex | Listing l} := ltac:(enumerate_finite_set).

  Definition example_openflow_entries := openflow_rules_generator
    ExampleVertex
    ltac:(prove_decidable_equality)
    ltac:(prove_valid_topology example_topology)
    example_policy
    (exist _ example_all_pairs_paths example_all_pairs_paths_valid)
    all_nodes
    ltac:(prove_injective_ips example_node_ips).

  Definition example_entries_by_node := map (fun node => (node, proj1_sig example_openflow_entries node)) (proj1_sig all_nodes).

  (* Warning: the line below produces a substantial amount of output (~3000 lines) *)
  Compute example_entries_by_node.
End NetworkExample.

Require Extraction.
Extraction Language OCaml.
Extract Inductive bool => "bool" [ "true" "false" ].
Extract Inductive sumbool => "bool" [ "true" "false" ].
Extract Inductive option => "option" [ "Some" "None" ].
Extract Inductive list => "list" [ "[]" "( :: )" ].
Extract Inductive prod => "( * )" [ "(, )" ].
Extraction "output/example_entries.ml" example_openflow_entries.
