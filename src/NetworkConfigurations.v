Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Program.Equality.
Require Import Coq.Logic.FinFun.
Require Import Coq.Bool.Bool.
Require Import ZArith.
Require Import bbv.Word.

Section Node.
  Context {Node : Set}.
  Definition Port : Set := word 16.
  Opaque Port.

  Record flow := {
    Src : Node;
    Dest : Node
  }.

  Definition network_topology := Node -> Node -> option Port.
  Definition valid_topology (topology : network_topology) := forall node outgoing1 outgoing2,
    match topology node outgoing1 with
    | Some port1 => port1 <> (natToWord 16 0) /\
      match topology node outgoing2 with
      | Some port2 => port1 = port2 -> outgoing1 = outgoing2
      | None => True
      end
    | None => True
    end.

  Definition static_network_policy := flow -> bool.

  Definition next_node := Node -> flow -> Node -> Prop.

  Fixpoint is_next_node_path (next : next_node) path here current_flow :=
    match path with
    | [] => here = current_flow.(Dest)
    | hop_target :: cdr =>
        next here current_flow hop_target /\
        is_next_node_path next cdr hop_target current_flow
    end.

  Record next_node_valid (topology : network_topology) (policy : static_network_policy) (next : next_node) := {
    all_hops_in_topology : forall here current_flow hop_target,
      next here current_flow hop_target -> if topology here hop_target then True else False;

    path_exists_only_for_valid_flows : forall current_flow,
      (policy current_flow = true \/ current_flow.(Src) = current_flow.(Dest)) <->
      exists path,
        is_next_node_path next path current_flow.(Src) current_flow;

    no_black_holes : forall here current_flow hop_target,
      (* TODO: Should this only be a requirement when a policy allows the flow?
         Currently, this constraint requires that disallowed packets be dropped at
         the first hop in the network, which limits some implementation choices.
      *)
      next here current_flow hop_target
        -> exists path, is_next_node_path next path hop_target current_flow;

    all_paths_acyclic : forall path here current_flow,
      is_next_node_path next path here current_flow -> NoDup (here :: path)
  }.

  Definition dec_next_node := Node -> flow -> option Node.

  Definition dec_next_node_valid (topology : network_topology) (policy : static_network_policy) (dec_next : dec_next_node) :=
    next_node_valid topology policy (fun here current_flow hop_target => dec_next here current_flow = Some hop_target).

  Fixpoint is_path_in_topology (topology : network_topology) src dest path :=
    match path with
    | [] => src = dest
    | hop_target :: cdr =>
      (if topology src hop_target then True else False) /\
      is_path_in_topology topology hop_target dest cdr
    end.

  Definition all_pairs_paths := Node -> Node -> option (list Node).

  Definition all_pairs_paths_next_node_generator
    (paths : all_pairs_paths)
    (topology : network_topology)
    (policy : static_network_policy)
    here
    current_flow
    hop_target
  :=
    policy current_flow = true /\
    match paths here current_flow.(Dest) with
    | Some (hop_target' :: _) => hop_target = hop_target'
    | _ => False
    end.

  Definition edge_costs := Node -> Port -> nat.

  Definition only_positive_costs (topology : network_topology) (costs : edge_costs) := forall n1 n2,
    match topology n1 n2 with
    | Some port => costs n1 port > 0
    | None => True
    end.

  Fixpoint path_cost topology (costs : edge_costs) src path :=
    match path with
    | [] => Some 0
    | car :: cdr =>
      match topology src car, path_cost topology costs car cdr with
      | Some port, Some remaining_cost => Some (costs src port + remaining_cost)
      | _, _ => None
      end
    end.

  Definition generates_decreasing_costs topology (paths : all_pairs_paths) costs :=
    only_positive_costs topology costs /\
    forall src dest,
      match paths src dest with
      | Some (hop_target :: cdr) =>
        match paths hop_target dest with
        | Some path =>
          match path_cost topology costs hop_target path, path_cost topology costs src (hop_target :: cdr) with
          | Some remaining_cost, Some original_cost => remaining_cost < original_cost
          | _, _ => False
          end
        | None => False
        end
      | _ => True
      end.

  Record all_pairs_paths_valid topology policy paths := {
    paths_in_topology : forall src dest,
      match paths src dest with
      | Some path => is_path_in_topology topology src dest path
      | _ => True
      end;
    paths_exist_for_valid_flows : forall current_flow,
      policy current_flow = true
        ->
          match paths current_flow.(Src) current_flow.(Dest) with
          | Some _ => True
          | None => False
          end;

    (* The consumer needs to show that some global cost function exists
       for which every hop on a path generated by `paths` will decrease
       the estimated total cost of the remainder the path. This is a
       sufficient condition to show prove the absence of cycles.
       (In practice, the consumer would likely start out with the cost function
       as an input based on environmental factors, then use it to generate
       a valid all-pairs paths function.) *)
    paths_move_closer_to_destination : exists (costs : edge_costs),
      generates_decreasing_costs topology paths costs
  }.

  Lemma all_pairs_paths_next_node_generator_creates_next_node_paths : forall paths topology policy current_flow hop_target,
    all_pairs_paths_valid topology policy paths
      -> policy current_flow = true
      -> match paths hop_target current_flow.(Dest) with | Some _ => True | None => False end
      -> exists path,
        is_next_node_path (all_pairs_paths_next_node_generator paths topology policy) path hop_target current_flow.
  Proof.
    intros.
    destruct_with_eqn (paths hop_target current_flow.(Dest)); try tauto.
    clear H1.
    assert (H' := H).
    apply paths_move_closer_to_destination in H'.
    destruct H', H1.
    assert (if path_cost topology x hop_target l then True else False).
    - destruct_with_eqn (path_cost topology x hop_target l); try tauto.
      specialize (H2 hop_target).
      specialize (H2 current_flow.(Dest)).
      rewrite Heqo in H2.
      destruct l; try (simpl in Heqo0; discriminate).
      repeat match goal with
      | [ H : match ?x with | Some _ => _ | None => False end |- _ ] => destruct x; try tauto
      | _ => discriminate
      end.
    - destruct_with_eqn (path_cost topology x hop_target l); try tauto.
      assert (match paths hop_target current_flow.(Dest) with | Some p => match path_cost topology x hop_target p with | Some cost' => cost' <= n | _ => False end | _ => False end) by (rewrite Heqo, Heqo0; omega).
      assert (n = 0 -> hop_target = current_flow.(Dest)).
      + intros.
        subst.
        destruct l.
        * eapply paths_in_topology in H.
          rewrite Heqo in H.
          tauto.
        * simpl in Heqo0.
          unfold only_positive_costs in H1.
          specialize (H1 hop_target).
          specialize (H1 n).
          destruct (topology hop_target n); try discriminate.
          destruct (path_cost topology x n l); try discriminate.
          assert (x hop_target p + n0 = 0) by (injection Heqo0; tauto).
          omega.
      + clear Heqo0 Heqo H3.
        dependent induction n generalizing hop_target; try (exists []; tauto).
        clear H5.
        destruct_with_eqn (paths hop_target current_flow.(Dest)); try tauto.
        destruct l0; try (exists []; simpl; eapply paths_in_topology in H; rewrite Heqo in H; simpl in H; subst; reflexivity).
        specialize (H2 hop_target).
        specialize (H2 current_flow.(Dest)).
        rewrite Heqo in H2.
        specialize (IHn n0).
        destruct (paths n0 current_flow.(Dest)); try tauto.
        destruct_with_eqn (path_cost topology x n0 l1); try tauto.
        destruct_with_eqn (path_cost topology x hop_target (n0 :: l0)); try tauto.
        assert (n1 <= n) by omega.
        apply IHn in H3.
        * destruct H3.
          exists (n0 :: x0).
          simpl.
          constructor; try assumption.
          unfold all_pairs_paths_next_node_generator.
          constructor; try assumption.
          rewrite Heqo.
          reflexivity.
        * intros.
          simpl in Heqo1.
          assert (n1 = 0) by omega.
          subst.
          destruct_with_eqn (topology hop_target n0); try discriminate.
          destruct_with_eqn (path_cost topology x n0 l0); try discriminate.
          assert (x hop_target p + n = n2) by (injection Heqo1; tauto).
          subst.
          clear Heqo1 H3 IHn.
          assert (x hop_target p > 0).
          --unfold only_positive_costs in H1.
            specialize (H1 hop_target).
            specialize (H1 n0).
            rewrite Heqo2 in H1.
            assumption.
          --destruct l0; simpl in Heqo.
            ++eapply paths_in_topology in H.
              rewrite Heqo in H.
              simpl in H.
              tauto.
            ++simpl in Heqo3.
              destruct_with_eqn (topology n0 n1); try discriminate.
              destruct_with_eqn (path_cost topology x n1 l0); try discriminate.
              assert (x n0 p0 + n2 = n) by (injection Heqo3; tauto).
              subst.
              enough (x n0 p0 > 0) by omega.
              specialize (H1 n0).
              specialize (H1 n1).
              rewrite Heqo1 in H1.
              assumption.
  Qed.

  Fixpoint has_strictly_decreasing_costs topology (paths : all_pairs_paths) (costs : edge_costs) l dest bound :=
    match l with
    | [] => True
    | node :: cdr =>
      match paths node dest with
      | Some l' =>
        match path_cost topology costs node l' with
        | Some cost => cost < bound /\ has_strictly_decreasing_costs topology paths costs cdr dest cost
        | None => False
        end
      | None => False
      end
    end.

  Lemma strictly_decreasing_costs_strengthening : forall topology paths costs l dest small_bound big_bound,
    has_strictly_decreasing_costs topology paths costs l dest small_bound
      -> small_bound <= big_bound
      -> has_strictly_decreasing_costs topology paths costs l dest big_bound.
  Proof.
    intros.
    destruct l; simpl; try tauto.
    simpl in H.
    repeat match goal with
    | [ H : match ?x with | Some _ => _ | None => False end |- _ ] => destruct x; try tauto
    end.
    destruct H.
    constructor; try tauto; omega.
  Qed.

  Lemma all_pairs_paths_generate_strictly_decreasing_costs : forall (paths : all_pairs_paths) costs topology policy here current_flow path path' first_bound,
    generates_decreasing_costs topology paths costs
      -> paths here current_flow.(Dest) = Some path'
      -> path_cost topology costs here path' = Some first_bound
      -> is_next_node_path (all_pairs_paths_next_node_generator paths topology policy) path here current_flow
      -> has_strictly_decreasing_costs topology paths costs path current_flow.(Dest) first_bound.
  Proof.
    intros.
    dependent induction path generalizing here; try (simpl; tauto).
    simpl.
    simpl in H2.
    destruct H2.
    unfold all_pairs_paths_next_node_generator in H2.
    destruct H2.
    rewrite H0 in H4.
    destruct path'; try tauto.
    subst.
    assert (H' := H).
    destruct H'.
    specialize (H5 here).
    specialize (H5 current_flow.(Dest)).
    rewrite H0 in H5.
    destruct_with_eqn (paths n current_flow.(Dest)); try tauto.
    destruct_with_eqn (path_cost topology costs n l); try tauto.
    destruct_with_eqn (path_cost topology costs here (n :: path')); try tauto.
    assert (n1 = first_bound) by (injection H1; tauto); subst.
    constructor; try assumption.
    eapply IHpath; eassumption.
  Qed.


  Lemma decreasing_costs_implies_nonmember : forall topology (paths : all_pairs_paths) costs path dest node path' first_bound,
    paths node dest = Some path'
      -> path_cost topology costs node path' = Some first_bound
      -> has_strictly_decreasing_costs topology paths costs path dest first_bound
      -> ~In node path.
  Proof.
    intros.
    dependent induction path; intros; simpl; try tauto.
    simpl in H1.
    destruct_with_eqn (paths a dest); try tauto.
    destruct_with_eqn (path_cost topology costs a l); try tauto.
    destruct H1.
    unfold not.
    intros.
    destruct H3.
    - subst.
      rewrite Heqo in H.
      injection H.
      intros.
      subst.
      rewrite Heqo0 in H0.
      assert (n = first_bound) by (injection H0; intros; tauto).
      omega.
    - enough (~(In node path)) by tauto.
      eapply IHpath; try eassumption.
      apply strictly_decreasing_costs_strengthening with (small_bound := n); try assumption.
      omega.
  Qed.

  Lemma NoDup_single : forall A (el : A), NoDup [el].
  Proof.
    intros.
    constructor.
    - unfold not; intros.
      inversion H.
    - constructor.
  Qed.

  Theorem all_pairs_paths_generator_valid : forall paths topology policy,
    all_pairs_paths_valid topology policy paths
      -> next_node_valid topology policy (all_pairs_paths_next_node_generator paths topology policy).
  Proof.
    intros.
    constructor; intros.
    - unfold all_pairs_paths_next_node_generator in H0.
      destruct H0.
      apply paths_in_topology with (src := here) (dest := current_flow.(Dest)) in H.
      destruct (paths here current_flow.(Dest)); try tauto.
      destruct l; try tauto.
      subst.
      simpl in H.
      tauto.
    - constructor.
      + intros.
        destruct H0.
        * apply all_pairs_paths_next_node_generator_creates_next_node_paths; try assumption.
          eapply paths_exist_for_valid_flows in H; eassumption.
        * exists [].
          simpl.
          assumption.
      + intros.
        destruct H0.
        destruct x; simpl in H0; try tauto.
        destruct H0.
        unfold all_pairs_paths_next_node_generator in H0.
        tauto.
    - unfold all_pairs_paths_next_node_generator in H0.
      destruct H0.
      apply all_pairs_paths_next_node_generator_creates_next_node_paths; try tauto.
      destruct_with_eqn (paths here current_flow.(Dest)); try tauto.
      destruct l; try tauto.
      subst.
      apply paths_move_closer_to_destination in H.
      destruct H.
      destruct H.
      specialize (H1 here).
      specialize (H1 current_flow.(Dest)).
      rewrite Heqo in H1.
      destruct (paths n current_flow.(Dest)); tauto.
    - dependent induction path; try apply NoDup_single.
      simpl in H0.
      destruct H0.
      unfold all_pairs_paths_next_node_generator in H0.
      destruct H0.
      destruct_with_eqn (paths here current_flow.(Dest)); try tauto.
      destruct l; try tauto.
      subst.
      assert (H1' := H1).
      apply IHpath in H1.
      constructor; try assumption.
      unfold not.
      intros.
      destruct H2.
      + subst.
        apply paths_move_closer_to_destination in H.
        destruct H.
        destruct H.
        specialize (H2 here).
        specialize (H2 current_flow.(Dest)).
        repeat rewrite Heqo in H2.
        simpl in H2.
        destruct (topology here here); try tauto.
        destruct (path_cost topology x here l); try tauto.
        omega.
      + enough (~(In here path)) by tauto.
        apply paths_move_closer_to_destination in H.
        destruct H.
        assert (H' := H).
        unfold generates_decreasing_costs in H'.
        destruct H'.
        specialize (H4 here).
        specialize (H4 current_flow.(Dest)).
        rewrite Heqo in H4.
        repeat match goal with
        | [ H : match ?x with | Some _ => _ | None => False end |- _ ] => destruct_with_eqn (x); try tauto
        end.
        eapply decreasing_costs_implies_nonmember with (costs := x); try eassumption.
        apply strictly_decreasing_costs_strengthening with (small_bound := n0); try omega.
        eapply all_pairs_paths_generate_strictly_decreasing_costs; eassumption.
  Qed.

  Definition all_pairs_paths_dec_next_node_generator
    (paths : all_pairs_paths)
    (topology : network_topology)
    (policy : static_network_policy)
    here
    current_flow
  :=
    if policy current_flow then
      match paths here current_flow.(Dest) with
      | Some (hop_target :: _) => Some hop_target
      | _ => None
      end
    else None.

  Lemma is_next_node_path_weakening : forall (strict_next lenient_next : next_node) path here current_flow,
    is_next_node_path strict_next path here current_flow
      -> (forall here' current_flow' hop_target, strict_next here' current_flow' hop_target -> lenient_next here' current_flow' hop_target)
      -> is_next_node_path lenient_next path here current_flow.
  Proof.
    intros.
    dependent induction path; simpl; simpl in H; try assumption.
    destruct H.
    assert (H0' := H0).
    apply IHpath with (here := a) (current_flow := current_flow) in H0; try tauto.
    constructor; try tauto.
    apply H0'; assumption.
  Qed.

  Lemma next_node_extensionality : forall next1 next2 topology policy,
    (forall here current_flow hop_target, next1 here current_flow hop_target <-> next2 here current_flow hop_target)
      -> next_node_valid topology policy next1
      -> next_node_valid topology policy next2.
  Proof.
    intros.
    constructor; intros; destruct H0.
    - eapply all_hops_in_topology0.
      apply H.
      eassumption.
    - constructor; intros.
      + apply path_exists_only_for_valid_flows0 in H0; try assumption.
        destruct H0.
        exists x.
        eapply is_next_node_path_weakening; try eassumption; apply H.
      + apply path_exists_only_for_valid_flows0.
        destruct H0.
        exists x.
        eapply is_next_node_path_weakening; try eassumption; apply H.
    - apply H in H1.
      apply no_black_holes0 in H1.
      destruct H1.
      exists x.
      eapply is_next_node_path_weakening; try eassumption; apply H.
    - eapply is_next_node_path_weakening in H1; try apply H.
      apply all_paths_acyclic0 in H1.
      assumption.
  Qed.

  Theorem all_pairs_paths_dec_generator_valid : forall paths topology policy,
    all_pairs_paths_valid topology policy paths
      -> dec_next_node_valid topology policy (all_pairs_paths_dec_next_node_generator paths topology policy).
  Proof.
    intros.
    apply all_pairs_paths_generator_valid in H.
    eapply next_node_extensionality; try eassumption.
    unfold all_pairs_paths_next_node_generator, all_pairs_paths_dec_next_node_generator.
    constructor; intros; repeat match goal with
    | [ H : _ /\ _ |- _ ] => destruct H
    | [ _ : _ |- _ /\ _ ] => constructor
    | [ H : context[match ?x with _ => _ end] |- _ ] => destruct x
    | [ H : ?x = _ |- context[?x] ] => rewrite H
    | [ H : _ ?a = _ ?b |- ?b = ?a ] => injection H; apply eq_sym
    | _ => tauto
    | _ => discriminate
    end.
  Qed.

  Definition routing_tables := Node -> list (flow * Node).

  Record routing_tables_valid (tables : routing_tables) (dec_next : dec_next_node) := {
    no_duplicate_entries : forall here,
      NoDup (tables here);

    entries_match_next_node_result : forall here current_flow hop_target,
      dec_next here current_flow = Some hop_target
        <-> In (current_flow, hop_target) (tables here)
  }.

  Definition routing_tables_generator := dec_next_node -> list Node -> routing_tables.

  Definition routing_tables_generator_valid (generator : routing_tables_generator) := forall dec_next all_nodes,
    Listing all_nodes
      -> routing_tables_valid
        (generator dec_next all_nodes)
        dec_next.

  Fixpoint map_filter {A} {B} (mapper : A -> option B) (l : list A) :=
    match l with
    | [] => []
    | car :: cdr =>
      match mapper car with
      | Some car' => car' :: map_filter mapper cdr
      | None => map_filter mapper cdr
      end
    end.

  Lemma map_filter_in_preservation : forall A B mapper l (element : A) (result : B),
    (forall (x y : A), {x = y} + {x <> y})
      -> mapper element = Some result
      -> In element l
      -> In result (map_filter mapper l).
  Proof.
    intros.
    dependent induction l; try (simpl in H0; tauto).
    assert ({a = element} + {a <> element}) by apply X.
    destruct H1.
    - subst.
      simpl.
      rewrite H.
      constructor.
      reflexivity.
    - simpl.
      assert (In result (map_filter mapper l)).
      + simpl in H0.
        destruct H0; try tauto.
        eapply IHl; eassumption.
      + destruct (mapper a); simpl; tauto.
  Qed.

  Lemma map_filter_in_filtering : forall A B mapper l (result : B),
    (forall (x y : B), {x = y} + {x <> y})
      -> In result (map_filter mapper l)
      -> {element : A | mapper element = Some result}.
  Proof.
    intros.
    dependent induction l; try (simpl in H; tauto).
    simpl in H.
    destruct_with_eqn (mapper a).
    - assert ({b = result} + {b <> result}) by apply X.
      destruct H0.
      + subst.
        apply exist with (x := a).
        assumption.
      + simpl in H.
        apply IHl; try assumption.
        destruct H; tauto.
    - apply IHl; assumption.
  Qed.

  Definition fst {A} {B} (pair : A * B) := match pair with | (l, _) => l end.
  Definition snd {A} {B} (pair : A * B) := match pair with | (_, r) => r end.

  Hypothesis Node_eq_dec : forall x y : Node, {x = y} + {x <> y}.
  Definition Node_pair_eq_dec : forall x y : (Node * Node), {x = y} + {x <> y}.
  Proof.
    intros.
    destruct x, y, Node_eq_dec with (x := n) (y := n1), Node_eq_dec with (x := n0) (y := n2); subst; try (constructor 1; reflexivity); constructor 2; congruence.
  Defined.

  Definition flow_Node_pair_eq_dec : forall x y : (flow * Node), {x = y} + {x <> y}.
  Proof.
    intros.
    destruct x, y, f, f0, Node_eq_dec with (x := Src0) (y := Src1), Node_eq_dec with (x := Dest0) (y := Dest1), Node_eq_dec with (x := n) (y := n0); subst; try (constructor 1; reflexivity); constructor 2; congruence.
  Defined.

  Definition flow_eq_dec : forall x y : flow, {x = y} + {x.(Src) <> y.(Src)} + {x.(Dest) <> y.(Dest)}.
  Proof.
    intros.
    destruct x, y, Node_eq_dec with (x := Src0) (y := Src1), Node_eq_dec with (x := Dest0) (y := Dest1); subst.
    - constructor 1; constructor 1; reflexivity.
    - constructor 2; simpl; tauto.
    - constructor 1; constructor 2; simpl; tauto.
    - constructor 2; simpl; tauto.
  Defined.

  Definition exhaustive_routing_tables_generator (dec_next : dec_next_node) (all_nodes : list Node) (here : Node) :=
    map_filter (fun pair =>
      match dec_next here {| Src := fst pair; Dest := snd pair |} with
      | Some hop_target => Some ({| Src := fst pair; Dest := snd pair |}, hop_target)
      | None => None
      end
    ) (nodup Node_pair_eq_dec (list_prod all_nodes all_nodes)).

  Theorem exhaustive_routing_tables_generator_valid : routing_tables_generator_valid exhaustive_routing_tables_generator.
  Proof.
    unfold exhaustive_routing_tables_generator.
    constructor; intros.
    - remember (nodup Node_pair_eq_dec (list_prod all_nodes all_nodes)) as pairs.
      assert (NoDup pairs) by (subst; apply NoDup_nodup).
      clear H Heqpairs.
      dependent induction pairs; try apply NoDup_nil.
      simpl.
      inversion_clear H0; subst.
      destruct a; simpl.
      destruct (dec_next here {| Src := n; Dest := n0 |}); try (apply IHpairs; assumption).
      constructor; try (apply IHpairs; assumption).
      clear IHpairs.
      dependent induction pairs; try (simpl; tauto).
      inversion_clear H1; subst.
      simpl.
      destruct (dec_next here {| Src := fst a; Dest := snd a |}).
      + simpl.
        unfold not.
        intros.
        destruct a.
        destruct H1.
        * injection H1.
          intros.
          subst.
          apply H0.
          simpl in H.
          tauto.
        * apply IHpairs in H1; try assumption.
          simpl in H.
          tauto.
      + simpl in H.
        apply IHpairs; tauto.
    - constructor; intros.
      + apply map_filter_in_preservation with (element := (current_flow.(Src), current_flow.(Dest))).
        * apply Node_pair_eq_dec.
        * destruct current_flow.
          simpl.
          rewrite H0.
          reflexivity.
        * apply nodup_In, in_prod; apply H.
      + apply map_filter_in_filtering in H0; try apply flow_Node_pair_eq_dec.
        destruct H0.
        assert (x = (current_flow.(Src), current_flow.(Dest))).
        * destruct (dec_next here {| Src := fst x; Dest := snd x |}); try discriminate.
          injection e.
          intros.
          subst.
          destruct x.
          simpl.
          reflexivity.
        * subst.
          destruct current_flow.
          simpl in e.
          destruct (dec_next here {| Src := Src0; Dest := Dest0 |}); try discriminate.
          congruence.
  Qed.

  Section OpenFlow.
    Definition ipv4_address : Type := word 8 * word 8 * word 8 * word 8.

    Definition ipv4_eqb (ip1 ip2 : ipv4_address) : bool :=
      match ip1, ip2 with
      | (a1, b1, c1, d1), (a2, b2, c2, d2) => weqb a1 a2 && weqb b1 b2 && weqb c1 c2 && weqb d1 d2
      end.

    Lemma ipv4_eqb_iff : forall ip1 ip2, ipv4_eqb ip1 ip2 = true <-> ip1 = ip2.
    Proof.
      intros; constructor.
      - intros; unfold ipv4_eqb in H; repeat match goal with
        | [ H : context[let (_, _) := ?i in _] |- _ ] => destruct i
        | [ H : (_ && _)%bool = true |- _ ] => unfold andb in H
        | [ H : (if ?e then ?f else false) = true |- _ ] => assert (e = true) by (destruct e; [reflexivity | discriminate]); assert (f = true) by (destruct e; [assumption | discriminate]); clear H
        | [ H : weqb ?a ?b = true |- _ ] => apply weqb_true_iff in H
        end; subst; reflexivity.
      - intros; unfold ipv4_eqb; repeat match goal with
        | [ |- context[let (_, _) := ?i in _] ] => destruct i
        | [ |- (_ && _)%bool = true ] => unfold andb
        | [ |- weqb ?w ?w = true ] => apply weqb_true_iff; reflexivity
        | [ H : weqb ?w ?w = true |- context[if weqb ?w ?w then _ else _] ] => rewrite H
        | [ |- context[if weqb ?w ?w then _ else _] ] => assert (weqb w w = true)
        | [ H : (?a, ?b, ?c, ?d) = (?e, ?f, ?g, ?h) |- _ ] => injection H; clear H; intros; subst
        end.
    Qed.

    Lemma ipv4_eqb_refl : forall ip, ipv4_eqb ip ip = true.
    Proof.
      intros.
      apply ipv4_eqb_iff.
      reflexivity.
    Qed.

    Record ipv4_packet := {
      IpSrc : ipv4_address;
      IpDest : ipv4_address
      (* Other fields exist but are not used here *)
    }.


    (* OpenFlow switch spec: https://www.opennetworking.org/wp-content/uploads/2013/04/openflow-spec-v1.0.0.pdf *)

    Record header_fields_matcher := {
      (* TODO: support IP wildcard matchers *)
      IpSrcMatcher : option ipv4_address;
      IpDestMatcher : option ipv4_address
      (* Other header fields exist but are not used here *)
    }.

    Inductive openflow_action :=
    | ForwardToPort : Port -> openflow_action
    | Drop
    | ReceiveAtDest
    (* Other actions exist but are not used here *)
    .

    Record openflow_flow_entry := {
      header_fields : header_fields_matcher;
      action : openflow_action (* This can actually be a list of actions, but only one is used here *)
      (* Entries also contain "counters" which are not used here *)
    }.

    Definition matches_header_fields_matcher (packet : ipv4_packet) (matcher : header_fields_matcher) : bool :=
      match matcher.(IpSrcMatcher) with
      | Some src_address => ipv4_eqb src_address packet.(IpSrc)
      | None => true
      end &&
      match matcher.(IpDestMatcher) with
      | Some dest_address => ipv4_eqb dest_address packet.(IpDest)
      | None => true
      end.

    Fixpoint get_matching_action packet openflow_flow_entries :=
      match openflow_flow_entries with
      | [] => Drop
      | entry :: cdr =>
        if matches_header_fields_matcher packet entry.(header_fields)
        then entry.(action)
        else get_matching_action packet cdr
      end.

    Definition node_ip_map := Node -> ipv4_address.
    Definition node_openflow_entry_map := Node -> list openflow_flow_entry.

    Inductive openflow_network_packet_state :=
    | EnRoute : node_ip_map -> node_openflow_entry_map -> network_topology -> ipv4_packet -> Node -> openflow_network_packet_state
    | Arrived
    | Dropped
    .

    Inductive openflow_network_step : openflow_network_packet_state -> openflow_network_packet_state -> Prop :=
    | ForwardPacket : forall node_ips entries ports port packet location new_location,
      get_matching_action packet (entries location) = ForwardToPort port
        -> ports location new_location = Some port
        -> ipv4_eqb (node_ips location) packet.(IpDest) = false
        -> openflow_network_step (EnRoute node_ips entries ports packet location) (EnRoute node_ips entries ports packet new_location)
    | DropPacket : forall node_ips entries ports packet location,
      get_matching_action packet (entries location) = Drop
        -> ipv4_eqb (node_ips location) packet.(IpDest) = false
        -> openflow_network_step (EnRoute node_ips entries ports packet location) Dropped
    | ReceivePacket : forall node_ips entries ports packet location,
      get_matching_action packet (entries location) = ReceiveAtDest
        -> ipv4_eqb (node_ips location) packet.(IpDest) = true
        -> openflow_network_step (EnRoute node_ips entries ports packet location) Arrived
    .

    Definition generate_openflow_entries
      (tables : routing_tables)
      (node_ips : node_ip_map)
      (topology : network_topology)
      node
    :=
      {|
        header_fields := {|
          IpSrcMatcher := None;
          IpDestMatcher := Some (node_ips node)
        |};
        action := ReceiveAtDest
      |} :: map (fun pair => {|
        header_fields := {|
          IpSrcMatcher := Some (node_ips pair.(fst).(Src));
          IpDestMatcher := Some (node_ips pair.(fst).(Dest))
        |};
        action := match topology node pair.(snd) with
        | Some port => ForwardToPort port

        (* Impossible if `tables` is valid for the topology *)
        | None => Drop
        end
      |}) (tables node).

    Fixpoint all_ports_exist (topology : network_topology) node openflow_flow_entries :=
      match openflow_flow_entries with
      | [] => True
      | entry :: cdr =>
        match entry.(action) with
        | ForwardToPort port => exists hop_target, topology node hop_target = Some port
        | Drop => True
        | ReceiveAtDest => True
        end /\ all_ports_exist topology node cdr
      end.

    Fixpoint always_reaches_state_after_bounded_steps desired_state num_steps current_state : Prop :=
      desired_state = current_state \/
      match num_steps with
      | 0 => False
      | S num_steps' =>
        (exists new_state, openflow_network_step current_state new_state) /\
        forall new_state,
          openflow_network_step current_state new_state
            -> always_reaches_state_after_bounded_steps desired_state num_steps' new_state
      end.

    Definition should_arrive (policy : static_network_policy) src dest :=
      if policy {| Src := src; Dest := dest |}
      then true
      else if Node_eq_dec src dest
        then true
        else false.

    Record valid_openflow_entries (topology : network_topology) (policy : static_network_policy) (node_ips : node_ip_map) (entry_map : node_openflow_entry_map) : Prop := {
      packets_arrive_iff_allowed : forall packet src_node dest_node,
        node_ips src_node = packet.(IpSrc)
          -> node_ips dest_node = packet.(IpDest)
          -> exists num_steps,

            (* Note: If the source/dest node have the same IP (or are the same node), this will always be true if num_steps >= 1 *)
            always_reaches_state_after_bounded_steps
              (if should_arrive policy src_node dest_node then Arrived else Dropped)
              num_steps
              (EnRoute node_ips entry_map topology packet src_node);
      existent_ports : forall node, all_ports_exist topology node (entry_map node)
    }.

    Record flow_transition_system {state} := {
      Initial : state;
      (* TODO: incorporate wall clock time *)
      Step : state -> flow -> state
    }.

    Arguments flow_transition_system : clear implicits.

    Definition join_transition_systems {A} {B} (sys1 : flow_transition_system A) (sys2 : flow_transition_system B) :=
      {|
        Initial := (sys1.(Initial), sys2.(Initial));
        Step := fun current_state next_flow => (Step sys1 current_state.(fst) next_flow, Step sys2 current_state.(snd) next_flow)
      |}.

    Inductive trc {state : Set} (step : state -> flow -> state) : state -> state -> Prop :=
    | TrcRefl : forall (start : state), trc step start start
    | TrcFront : forall start mid dest sent_flow,
      step start sent_flow = mid
        -> trc step mid dest
        -> trc step start dest
    .

    Arguments trc {state} step.

    Definition invariant {state : Set} (sys : flow_transition_system state) (condition : state -> Prop) := forall new_state,
      trc sys.(Step) sys.(Initial) new_state
        -> condition new_state.

    Lemma invariant_weakening {state : Set} : forall sys (weak_condition strong_condition : state -> Prop),
      invariant sys strong_condition
        -> (forall s, strong_condition s -> weak_condition s)
        -> invariant sys weak_condition.
    Proof.
      unfold invariant; eauto.
    Qed.

    Record dynamic_network_policy {policy_state : Set} := {
      policy_system : flow_transition_system policy_state;

      policy_state_decider : policy_state -> static_network_policy
    }.

    Definition filter_transition_system {state} (predicate : state -> flow -> bool) (sys : flow_transition_system state) :=
      {|
        Initial := sys.(Initial);
        Step := fun current_state next_flow =>
          if predicate current_state next_flow
          then sys.(Step) current_state next_flow
          else current_state
      |}.

    Lemma filter_transition_system_trc {state : Set} : forall predicate (sys : flow_transition_system state) new_state,
      let filtered_sys := filter_transition_system predicate sys in
      trc filtered_sys.(Step) filtered_sys.(Initial) new_state
        -> trc sys.(Step) sys.(Initial) new_state.
    Proof.
      intros.
      unfold filtered_sys, filter_transition_system in H.
      simpl in H.
      clear Node_eq_dec filtered_sys.
      remember sys.(Initial) as start_state; clear Heqstart_state.
      dependent induction H; try apply TrcRefl.
      destruct (predicate start sent_flow).
      - eapply TrcFront; eassumption.
      - subst; assumption.
    Qed.

    Section NetworkSystem.
      Context {policy_state : Set}.
      Variable topology : network_topology.
      Variable policy : @dynamic_network_policy policy_state.
      Variable node_ips : node_ip_map.

      Record network_controller {controller_state} := {
        controller_system : flow_transition_system controller_state;

        controller_state_decider : controller_state -> node_openflow_entry_map
      }.

      Definition dynamic_policy_valid paths :=
        let filtered_policy_sys := filter_transition_system policy.(policy_state_decider) policy.(policy_system) in
        invariant filtered_policy_sys (fun current_state =>
          all_pairs_paths_valid topology (policy.(policy_state_decider) current_state) paths
        ).

      Definition controller_implements_policy {controller_state : Set} (controller : @network_controller controller_state) :=
        let joined_sys := filter_transition_system (fun current_state next_flow =>

          (* state only changes for flows that are allowed by the current policy *)
          policy.(policy_state_decider) current_state.(fst) next_flow
        ) (join_transition_systems policy.(policy_system) controller.(controller_system)) in
        invariant joined_sys (fun policy_and_controller_state =>
          let (policy_state, controller_state) := policy_and_controller_state in
          valid_openflow_entries topology (policy.(policy_state_decider) policy_state) node_ips (controller.(controller_state_decider) controller_state)
        ).
    End NetworkSystem.

    Lemma get_matching_action_forwards_to_correct_port : forall topology dec_next current_flow here hop_target port node_ips all_nodes,
      dec_next here current_flow = Some hop_target
        -> topology here hop_target = Some port
        -> Injective node_ips
        -> Listing all_nodes
        -> routing_tables_valid (exhaustive_routing_tables_generator dec_next all_nodes) dec_next
        -> here <> current_flow.(Dest)
        -> get_matching_action
          {| IpSrc := node_ips current_flow.(Src); IpDest := node_ips current_flow.(Dest) |}
          (generate_openflow_entries (exhaustive_routing_tables_generator dec_next all_nodes) node_ips topology here)
          = ForwardToPort port.
    Proof.
      intros.
      assert (forall hop, dec_next here current_flow = Some hop <-> In (current_flow, hop) (exhaustive_routing_tables_generator dec_next all_nodes here)) by (intros; apply entries_match_next_node_result; assumption).
      clear H3.
      unfold generate_openflow_entries.
      induction (exhaustive_routing_tables_generator dec_next all_nodes here); [ apply H5 in H; inversion H | idtac ].
      simpl.
      destruct a.
      assert ({current_flow = f} + {current_flow.(Src) <> f.(Src)} + {current_flow.(Dest) <> f.(Dest)}) by (apply flow_eq_dec).
      destruct H3; [ destruct s | idtac ].
      - destruct current_flow, f; injection e; intros; subst; simpl.
        unfold matches_header_fields_matcher.
        simpl.
        repeat rewrite ipv4_eqb_refl.
        simpl.
        destruct_with_eqn (ipv4_eqb (node_ips here) (node_ips Dest1)); try (apply ipv4_eqb_iff, H1 in Heqb; tauto).
        enough (hop_target = n) by (rewrite <- H3, H0; reflexivity).
        enough (Some hop_target = Some n) by (injection H3; tauto).
        rewrite <- H.
        apply H5.
        constructor.
        reflexivity.
      - unfold matches_header_fields_matcher.
        simpl.
        destruct_with_eqn (ipv4_eqb (node_ips f.(Src)) (node_ips current_flow.(Src))); [ apply ipv4_eqb_iff, H1, eq_sym in Heqb; tauto | idtac ].
        simpl.
        apply IHl.
        intros.
        constructor; intros; try (apply H5; constructor 2; assumption).
        apply H5 in H3.
        inversion_clear H3; try assumption.
        congruence.
      - unfold matches_header_fields_matcher.
        simpl.
        destruct_with_eqn (ipv4_eqb (node_ips f.(Dest)) (node_ips current_flow.(Dest))); [ apply ipv4_eqb_iff, H1, eq_sym in Heqb; tauto | idtac ].
        rewrite andb_false_r.
        (* FIXME: the lines below here are duplicated from the above subgoal *)
        apply IHl.
        intros.
        constructor; intros; try (apply H5; constructor 2; assumption).
        apply H5 in H3.
        inversion_clear H3; try assumption.
        congruence.
    Qed.

    Lemma get_matching_action_drops : forall topology dec_next current_flow here node_ips all_nodes,
      dec_next here current_flow = None
        -> Injective node_ips
        -> Listing all_nodes
        -> routing_tables_valid (exhaustive_routing_tables_generator dec_next all_nodes) dec_next
        -> here <> current_flow.(Dest)
        -> get_matching_action
          {| IpSrc := node_ips current_flow.(Src); IpDest := node_ips current_flow.(Dest) |}
          (generate_openflow_entries (exhaustive_routing_tables_generator dec_next all_nodes) node_ips topology here)
          = Drop.
    Proof.
      intros.
      assert (forall hop, dec_next here current_flow = Some hop <-> In (current_flow, hop) (exhaustive_routing_tables_generator dec_next all_nodes here)) by (intros; apply entries_match_next_node_result; assumption).
      clear H2.
      unfold generate_openflow_entries.
      simpl.
      unfold matches_header_fields_matcher.
      simpl.
      destruct_with_eqn (ipv4_eqb (node_ips here) (node_ips current_flow.(Dest))); try (apply ipv4_eqb_iff, H0 in Heqb; tauto).
      induction (exhaustive_routing_tables_generator dec_next all_nodes here); try reflexivity.
      simpl.
      unfold matches_header_fields_matcher.
      destruct a.
      simpl.
      assert ({current_flow = f} + {current_flow.(Src) <> f.(Src)} + {current_flow.(Dest) <> f.(Dest)}) by (apply flow_eq_dec).
      destruct H2; [ destruct s | idtac ].
      - subst.
        assert (dec_next here f = Some n) by (apply H4; simpl; tauto).
        rewrite H2 in H.
        discriminate.
      (* TODO: combine this proof with `get_matching_action_forwards_to_correct_port`
        and extract duplicated portions into an ltac script *)
      - destruct_with_eqn (ipv4_eqb (node_ips f.(Src)) (node_ips current_flow.(Src))); [ apply ipv4_eqb_iff, H0, eq_sym in Heqb0; tauto | idtac ].
        apply IHl.
        intros.
        constructor; intros; try (apply H4; constructor 2; assumption).
        apply H4 in H2.
        inversion_clear H2; try assumption.
        congruence.
      - destruct_with_eqn (ipv4_eqb (node_ips f.(Dest)) (node_ips current_flow.(Dest))); [ apply ipv4_eqb_iff, H0, eq_sym in Heqb0; tauto | idtac ].
        rewrite andb_false_r.
        apply IHl.
        intros.
        constructor; intros; try (apply H4; constructor 2; assumption).
        apply H4 in H2.
        inversion_clear H2; try assumption.
        congruence.
    Qed.

    Lemma dec_next_creates_valid_unique_state_transitions : forall topology policy dec_next node_ips (packet : ipv4_packet) here current_flow all_nodes openflow_entries,
      dec_next_node_valid topology policy dec_next
        -> valid_topology topology
        -> Listing all_nodes
        -> Injective node_ips
        -> openflow_entries = generate_openflow_entries (exhaustive_routing_tables_generator dec_next all_nodes) node_ips topology
        -> packet = {| IpSrc := node_ips current_flow.(Src); IpDest := node_ips current_flow.(Dest) |}
        -> here <> current_flow.(Dest)
        -> (
          (exists new_state, openflow_network_step (EnRoute node_ips openflow_entries topology packet here) new_state) /\
          forall new_state,
            openflow_network_step (EnRoute node_ips openflow_entries topology packet here) new_state
              -> new_state =
                  match dec_next here current_flow with
                  | Some hop_target => EnRoute node_ips openflow_entries topology packet hop_target
                  | None => Dropped
                  end
        ).
    Proof.
      intros.
      assert (routing_tables_valid (exhaustive_routing_tables_generator dec_next all_nodes) dec_next) by (apply exhaustive_routing_tables_generator_valid; assumption).
      constructor; destruct_with_eqn (dec_next here current_flow).
      - exists (EnRoute node_ips openflow_entries topology packet n).
        apply all_hops_in_topology with (topology := topology) (policy := policy) (here := here) (hop_target := n) (current_flow := current_flow) in H; try assumption.
        destruct_with_eqn (topology here n); try tauto.
        apply ForwardPacket with (port := p); try assumption.
        + subst.
          apply get_matching_action_forwards_to_correct_port with (hop_target := n); assumption.
        + rewrite H4.
          simpl.
          destruct_with_eqn (ipv4_eqb (node_ips here) (node_ips current_flow.(Dest))); try reflexivity.
          apply ipv4_eqb_iff, H2 in Heqb; tauto.
      - exists Dropped.
        subst.
        constructor; simpl; try (apply get_matching_action_drops; assumption).
        destruct_with_eqn (ipv4_eqb (node_ips here) (node_ips current_flow.(Dest))); try reflexivity.
        apply ipv4_eqb_iff, H2 in Heqb; tauto.
      - intros.
        inversion_clear H7; subst.
        + apply all_hops_in_topology with (topology := topology) (policy := policy) (here := here) (hop_target := n) (current_flow := current_flow) in H; try assumption.
          destruct_with_eqn (topology here n); try tauto.
          assert (
            get_matching_action
              {| IpSrc := node_ips current_flow.(Src); IpDest := node_ips current_flow.(Dest) |}
              (generate_openflow_entries (exhaustive_routing_tables_generator dec_next all_nodes) node_ips topology here)
            = ForwardToPort p
          ) by (apply get_matching_action_forwards_to_correct_port with (hop_target := n); assumption).
          rewrite H3 in H8.
          injection H8; intros; subst.
          enough (n = new_location) by (subst; reflexivity).
          specialize (H0 here).
          specialize (H0 n).
          specialize (H0 new_location).
          rewrite Heqo0, H9 in H0.
          apply H0.
          reflexivity.
        + apply all_hops_in_topology with (topology := topology) (policy := policy) (here := here) (hop_target := n) (current_flow := current_flow) in H; try assumption.
          destruct_with_eqn (topology here n); try tauto.
          assert (
            get_matching_action
              {| IpSrc := node_ips current_flow.(Src); IpDest := node_ips current_flow.(Dest) |}
              (generate_openflow_entries (exhaustive_routing_tables_generator dec_next all_nodes) node_ips topology here)
            = ForwardToPort p
          ) by (apply get_matching_action_forwards_to_correct_port with (hop_target := n); assumption).
          rewrite H3 in H8.
          discriminate.
        + apply ipv4_eqb_iff, H2 in H9.
          tauto.
      - intros.
        inversion_clear H7; subst; try reflexivity.
        + assert (
            get_matching_action
              {| IpSrc := node_ips current_flow.(Src); IpDest := node_ips current_flow.(Dest) |}
              (generate_openflow_entries (exhaustive_routing_tables_generator dec_next all_nodes) node_ips topology here)
            = Drop
          ) by (apply get_matching_action_drops; assumption).
          rewrite H3 in H8.
          discriminate.
        + apply ipv4_eqb_iff, H2 in H9.
          tauto.
    Qed.

    Lemma reaches_arrived_state_from_destination_in_one_step : forall node_ips topology tables src_node dest_node,
      always_reaches_state_after_bounded_steps
        Arrived
        1
        (EnRoute node_ips (generate_openflow_entries tables node_ips topology) topology {| IpSrc := node_ips src_node; IpDest := node_ips dest_node |} dest_node).
    Proof.
      intros.
      simpl.
      apply or_intror.
      constructor.
      - exists Arrived.
        constructor.
        + simpl.
          unfold matches_header_fields_matcher.
          simpl.
          rewrite ipv4_eqb_refl.
          reflexivity.
        + simpl.
          apply ipv4_eqb_refl.
      - intros.
        apply or_introl.
        inversion_clear H; try reflexivity; subst; repeat match goal with
        | [ H : context[IpDest {| IpSrc := _; IpDest := _ |}] |- _ ] => simpl in H
        | [ H : ipv4_eqb ?x ?x = false |- _ ] => rewrite ipv4_eqb_refl in H; discriminate
        end.
    Qed.

    Lemma always_reaches_state_after_bounded_steps_weakening : forall desired_state big_num_steps small_num_steps current_state,
      always_reaches_state_after_bounded_steps desired_state small_num_steps current_state
        -> small_num_steps <= big_num_steps
        -> always_reaches_state_after_bounded_steps desired_state big_num_steps current_state.
    Proof.
      intros.
      dependent induction small_num_steps generalizing big_num_steps.
      - simpl in H.
        destruct H; try tauto.
        destruct big_num_steps; simpl; tauto.
      - destruct big_num_steps; try omega.
        simpl.
        destruct H; [ apply or_introl | apply or_intror ]; try assumption.
        destruct H.
        constructor; try assumption.
        intros.
        apply IHsmall_num_steps.
        + apply H1; assumption.
        + omega.
    Qed.

    Lemma disallowed_flow_immediately_dropped : forall topology policy next src dest hop_target,
      next_node_valid topology policy next
        -> policy {| Src := src; Dest := dest |} = false
        -> ~next src {| Src := src; Dest := dest |} hop_target.
    Proof.
      unfold not.
      intros.
      assert (H' := H).
      assert (H'' := H).
      apply path_exists_only_for_valid_flows with (current_flow := {| Src := src; Dest := dest |}) in H.
      simpl in H.
      apply no_black_holes with (topology := topology) (policy := policy) (current_flow := {| Src := src; Dest := dest |}) (here := src) (hop_target := hop_target) in H'; try assumption.
      destruct H'.
      assert (exists path, is_next_node_path next path src {| Src := src; Dest := dest |}) by (exists (hop_target :: x); constructor; tauto).
      apply H in H3.
      destruct H3.
      - rewrite H0 in H3.
        discriminate.
      - subst.
        apply all_paths_acyclic with (path := (hop_target :: x)) (here := dest) (current_flow := {| Src := dest; Dest := dest |}) in H''; try (constructor; assumption).
        clear H0 H H1.
        dependent induction x generalizing hop_target.
        + simpl in H2.
          subst.
          inversion_clear H''.
          apply H.
          constructor.
          reflexivity.
        + apply IHx with (hop_target := a); try (simpl in H2; tauto).
          inversion_clear H''; subst.
          inversion_clear H0; subst.
          constructor; try assumption.
          simpl.
          simpl in H.
          tauto.
    Qed.

    Lemma disallowed_packet_eventually_dropped : forall topology policy dec_next all_nodes node_ips src dest,
      valid_topology topology
        -> Listing all_nodes
        -> Injective node_ips
        -> dec_next_node_valid topology policy dec_next
        -> policy {| Src := src; Dest := dest |} = false
        -> src <> dest
        -> exists num_steps,
          always_reaches_state_after_bounded_steps Dropped num_steps (
            EnRoute node_ips
              (
                generate_openflow_entries
                  (exhaustive_routing_tables_generator dec_next all_nodes)
                  node_ips
                  topology
              )
              topology
              {| IpSrc := node_ips src; IpDest := node_ips dest |}
              src
          ).
    Proof.
      intros.
      (* Currently, the definition of validity requires disallowed
         packets to be *immediately* dropped, which simplifies
         this proof. *)
      exists 1.
      assert (dec_next src {| Src := src; Dest := dest |} = None).
      - destruct_with_eqn (dec_next src {| Src := src; Dest := dest |}); try reflexivity.
        apply disallowed_flow_immediately_dropped with (src := src) (dest := dest) (hop_target := n) in H2; tauto.
      - simpl.
        apply or_intror.
        eapply dec_next_creates_valid_unique_state_transitions with (current_flow := {| Src := src; Dest := dest |}) in H2; try eassumption; try reflexivity.
        simpl in H2.
        constructor; try tauto.
        intros.
        apply or_introl, eq_sym.
        destruct H2.
        eassert (Dropped = match dec_next src _ with | Some _ => _ | None => Dropped end) by (rewrite H5; reflexivity).
        rewrite H8.
        apply H7.
        assumption.
    Qed.

    Theorem openflow_rules_generator_validity : forall topology policy paths all_nodes node_ips,
      valid_topology topology
        -> all_pairs_paths_valid topology policy paths
        -> Listing all_nodes
        -> Injective node_ips
        -> valid_openflow_entries
          topology
          policy
          node_ips
          (
            generate_openflow_entries
            (
              exhaustive_routing_tables_generator
              (all_pairs_paths_dec_next_node_generator paths topology policy)
              all_nodes
            )
            node_ips
            topology
          ).
    Proof.
      intros.
      set (dec_next := all_pairs_paths_dec_next_node_generator paths topology policy).
      set (tables := exhaustive_routing_tables_generator dec_next all_nodes).
      set (openflow_entries := generate_openflow_entries tables node_ips topology).
      assert (dec_next_node_valid topology policy dec_next) by (apply all_pairs_paths_dec_generator_valid; assumption).
      assert (routing_tables_valid tables dec_next) by (apply exhaustive_routing_tables_generator_valid; assumption).
      constructor; intros.
      - unfold dec_next_node_valid in H3.
        assert (dec_next_node_valid topology policy dec_next) by (apply all_pairs_paths_dec_generator_valid; assumption).
        assert (H' := H7).
        apply path_exists_only_for_valid_flows with (current_flow := {| Src := src_node; Dest := dest_node |}) in H7; try (simpl; assumption).
        simpl in H7.
        assert ((policy {| Src := src_node; Dest := dest_node |} = true \/ src_node = dest_node) <-> should_arrive policy src_node dest_node = true). {
          unfold should_arrive.
          repeat match goal with
          | [ |- context[if ?x then _ else _] ] => destruct x
          | _ => tauto
          end.
        }
        rewrite H8 in H7.
        clear H8.
        destruct_with_eqn (should_arrive policy src_node dest_node).
        + clear Heqb.
          assert (exists path, _) by (apply H7; reflexivity).
          clear H7.
          destruct H8.
          exists (S (length x)).
          remember {| Src := src_node; Dest := dest_node |} as flow.
          assert (node_ips flow.(Src) = IpSrc packet) by (rewrite <- H5, Heqflow; tauto).
          assert (node_ips flow.(Dest) = IpDest packet) by (rewrite <- H6, Heqflow; tauto).
          clear H5 H6 Heqflow.
          destruct packet.
          simpl in H8, H9.
          subst.
          dependent induction x generalizing src_node; try (simpl in H7; subst; apply reaches_arrived_state_from_destination_in_one_step).
          assert ({src_node = flow0.(Dest)} + {src_node <> flow0.(Dest)}) by (apply Node_eq_dec).
          destruct H5.
          * subst.
            apply always_reaches_state_after_bounded_steps_weakening with (small_num_steps := 1); try omega.
            apply reaches_arrived_state_from_destination_in_one_step.
          * destruct H7.
            apply IHx in H6; try assumption.
            remember (a :: x) as path.
            assert (S (length x) = length path) by (rewrite Heqpath; simpl; reflexivity).
            rewrite H7 in H6.
            clear Heqpath H7.
            simpl.
            apply or_intror.
            remember (length path) as remaining_steps; clear Heqremaining_steps path.
            eassert (_ /\ _) by (apply dec_next_creates_valid_unique_state_transitions with (policy := policy) (dec_next := dec_next) (current_flow := flow0) (all_nodes := all_nodes) (openflow_entries := openflow_entries); try eassumption; eauto).
            destruct H7.
            constructor; try assumption.
            intros.
            apply H8 in H9.
            subst.
            rewrite H5.
            assumption.
        + unfold should_arrive in Heqb.
          assert (policy {| Src := src_node; Dest := dest_node |} = false) by (destruct (policy {| Src := src_node; Dest := dest_node |}); firstorder discriminate).
          assert (src_node <> dest_node) by (destruct (Node_eq_dec src_node dest_node), (policy {| Src := src_node; Dest := dest_node |}); try discriminate; assumption).
          clear Heqb H7.
          destruct packet.
          unfold openflow_entries, tables.
          simpl in H5, H6.
          rewrite <- H5, <- H6.
          eapply disallowed_packet_eventually_dropped; eassumption.
      - unfold openflow_entries, generate_openflow_entries.
        set (node_tables := tables node).
        simpl.
        constructor.
        tauto.
        dependent induction node_tables; simpl; try tauto.
        constructor; try assumption.
        destruct_with_eqn (topology node a.(snd)); try tauto.
        eexists; eassumption.
    Qed.

    Definition openflow_rules_generator
      (topology : {t : network_topology | valid_topology t})
      (policy : static_network_policy)
      (paths : {pairs_paths : all_pairs_paths | all_pairs_paths_valid (proj1_sig topology) policy pairs_paths})
      (all_nodes : {enumeration : list Node | Listing enumeration})
      (node_ips : {ips : node_ip_map | Injective ips})
    : {entries : node_openflow_entry_map | valid_openflow_entries (proj1_sig topology) policy (proj1_sig node_ips) entries}.
    Proof.
      econstructor.
      apply openflow_rules_generator_validity with (paths := proj1_sig paths) (all_nodes := proj1_sig all_nodes); exact (proj2_sig _).
    Defined.

    Theorem dynamic_controller_generator_validity : forall (policy_state : Set) topology (policy : @dynamic_network_policy policy_state) paths all_nodes node_ips,
      valid_topology topology
        -> dynamic_policy_valid topology policy paths
        -> Listing all_nodes
        -> Injective node_ips
        -> controller_implements_policy topology policy node_ips {|
          controller_system := policy.(policy_system);
          controller_state_decider := fun state =>
          (
            generate_openflow_entries
            (
              exhaustive_routing_tables_generator
              (all_pairs_paths_dec_next_node_generator paths topology (policy.(policy_state_decider) state))
              all_nodes
            )
            node_ips
            topology
          )
        |}.
    Proof.
      unfold controller_implements_policy, dynamic_policy_valid, invariant.
      intros.
      destruct new_state.
      simpl in H3.
      assert (p = p0).
      - destruct policy.(policy_system).
        clear - H3.
        dependent induction H3; try reflexivity.
        simpl in H3, IHtrc.
        destruct (policy_state_decider policy Initial0 sent_flow); eapply IHtrc; reflexivity.
      - subst.
        apply openflow_rules_generator_validity; try assumption.
        apply H0.
        unfold filter_transition_system.
        simpl.
        destruct policy.(policy_system).
        clear - H3.
        simpl.
        simpl in H3.
        dependent induction H3; try apply TrcRefl.
        destruct_with_eqn (policy_state_decider policy Initial0 sent_flow).
        + eapply TrcFront with (sent_flow0 := sent_flow); try reflexivity.
          apply IHtrc; simpl; try rewrite Heqb; reflexivity.
        + apply IHtrc; simpl; try rewrite Heqb; reflexivity.
    Qed.

    Definition dynamic_controller_generator
      {policy_state : Set}
      (topology : {t : network_topology | valid_topology t})
      (policy : @dynamic_network_policy policy_state)
      (paths: {pairs_paths : all_pairs_paths | dynamic_policy_valid (proj1_sig topology) policy pairs_paths})
      (all_nodes : {enumeration : list Node | Listing enumeration})
      (node_ips : {ips : node_ip_map | Injective ips})
    : {controller : @network_controller policy_state | controller_implements_policy (proj1_sig topology) policy (proj1_sig node_ips) controller}.
    Proof.
      econstructor.
      apply dynamic_controller_generator_validity with (paths := proj1_sig paths) (all_nodes := proj1_sig all_nodes); exact (proj2_sig _).
    Defined.
  End OpenFlow.
End Node.

Ltac prove_decidable_equality :=
  let Node := match goal with
  | [ |- forall x y : ?Node, {x = y} + {x <> y} ] => Node
  | _ => fail 1 "Unexpected goal in decidable equality proof"
  end in
  intros;
  repeat match goal with
  | [ x : Node |- _ ] => destruct x
  end;
  firstorder discriminate.

Ltac prove_valid_topology topology :=
  let Node := match goal with
  | [ |- {t : @network_topology ?Node | valid_topology t} ] => Node
  | _ => fail 1 "Unexpected goal in valid topology proof"
  end in
  apply exist with (x := topology);
  unfold valid_topology;
  intros;
  repeat match goal with
  | [ x : Node |- _ ] => destruct x
  end;
  simpl;
  try reflexivity;
  try firstorder discriminate.

Ltac prove_injective_ips node_ips :=
  let Node := match goal with
  | [ |- {ips : @node_ip_map ?Node | Injective ips} ] => Node
  | _ => fail 1 "Unexpected goal in injective IPs proof"
  end in
  apply exist with (x := node_ips);
  unfold Injective;
  intros;
  repeat match goal with
  | [ x : Node |- _ ] => destruct x
  end;
  try reflexivity;
  try discriminate.

Ltac enumerate_finite_set :=
  let Node := match goal with
  | [ |- {l : list ?Node | Listing l} ] => Node
  | _ => fail 1 "Unexpected goal in finite set enumeration"
  end in
  econstructor;
  unfold Listing, Full;
  constructor;
  [
    idtac |
    intros;
    match goal with
    | [ node : Node |- _ ] => destruct node
    end;
    unshelve (
      let cdr := fresh "cdr" in
        evar (cdr : list Node);
        let cdr' := (eval unfold cdr in cdr) in
          clear cdr;
          match goal with
          | [ |- In ?n _ ] => instantiate (1 := n :: cdr')
          end;
          simpl;
          tauto
    );
    exact []
  ];
  repeat constructor;
  firstorder discriminate.

Fixpoint map_with_index' {A} {B} (f : A -> nat -> B) (l : list A) (start_index : nat) :=
  match l with
  | [] => []
  | car :: cdr => (f car start_index) :: map_with_index' f cdr (S start_index)
  end.

Definition map_with_index {A} {B} (f : A -> nat -> B) (l : list A) := map_with_index' f l 0.

Definition set_value_at {A} (lst : list (list A)) (i j : nat) (val : A) :=
  map_with_index (fun row row_index =>
    if row_index =? i
    then map_with_index (fun entry col_index => if col_index =? j then val else entry) row
    else row
  ) lst.

Definition get_value_at {A} (lst : list (list A)) (i j : nat) :=
  match nth_error lst i with
  | Some row =>
    match nth_error row j with
    | Some entry => Some entry
    | None => None
    end
  | None => None
  end.

Definition distance_can_be_shortened (dists : list (list (option nat))) (i j k : nat) :=
  match get_value_at dists i j, get_value_at dists i k, get_value_at dists k j with
  | Some None, Some (Some i_k), Some (Some k_j) => Some (i_k + k_j)
  | Some (Some i_j), Some (Some i_k), Some (Some k_j) => if i_k + k_j <? i_j then Some (i_k + k_j) else None
  | _, _, _ => None
  end.

Fixpoint find_index {Node} (Node_eq_dec : forall (n1 n2 : Node), {n1 = n2} + {n1 <> n2}) nodes node :=
  match nodes with
  | [] => None
  | car :: cdr =>
    if Node_eq_dec car node
    then Some 0
    else match find_index Node_eq_dec cdr node with
    | Some cdr_index => Some (S cdr_index)
    | None => None
    end
  end.

Fixpoint next_matrix_to_paths {Node} (Node_eq_dec : forall (n1 n2 : Node), {n1 = n2} + {n1 <> n2}) all_nodes max_length next_matrix nodeA nodeB :=
  if Node_eq_dec nodeA nodeB
  then Some []
  else match max_length with
  | 0 => None
  | S max_length' =>
    let indexA := find_index Node_eq_dec all_nodes nodeA in
    let indexB := find_index Node_eq_dec all_nodes nodeB in
    match indexA, indexB with
    | Some iA, Some iB =>
      match nth_error next_matrix iA with
      | Some nodeA_row =>
        match nth_error nodeA_row iB with
        | Some (Some hop) =>
          match next_matrix_to_paths Node_eq_dec all_nodes max_length' next_matrix hop nodeB with
          | Some cdr_path => Some (hop :: cdr_path)
          | None => None
          end
        | _ => None
        end
      | None => None
      end
    | _, _ => None
    end
  end.

(* Implements the Floyd-Warshall algorithm *)
Ltac generate_all_pairs_paths Node Node_eq_dec topology all_nodes costs :=
  let nodes := (eval unfold all_nodes in all_nodes.(proj1_sig)) in
  let dists := fresh "dists" in
  let nexts := fresh "nexts" in
  set (dists := map (fun n1 =>
    map (fun n2 =>
      if Node_eq_dec n1 n2
      then Some 0
      else match topology n1 n2 with
      | Some port => Some (costs n1 port)
      | None => None
      end
    ) nodes
  ) nodes);
  set (nexts := map (fun n1 =>
    map (fun n2 =>
      if Node_eq_dec n1 n2
      then Some n1
      else match topology n1 n2 with
      | Some _ => Some n2
      | None => None
      end
    ) nodes
  ) nodes);
  let num_nodes := eval compute in (length nodes) in
  let k := fresh "k" in
  set (k := 0);
  repeat (
    match (eval compute in k) with
    | num_nodes => fail 1
    | _ => idtac
    end;

    let i := fresh "i" in
    set (i := 0);
    repeat (
      match (eval compute in i) with
      | num_nodes => fail 1
      | _ => idtac
      end;

      let j := fresh "j" in
      set (j := 0);
      repeat (
        match (eval compute in j) with
        | num_nodes => fail 1
        | _ => idtac
        end;

        match eval compute in (distance_can_be_shortened dists i j k) with
        | Some ?short_distance =>
          let dists' := eval compute in (set_value_at dists i j (Some short_distance)) in (
            clear dists;
            set (dists := dists')
          );
          let nexts' := eval compute in (
            set_value_at nexts i j (
              match get_value_at nexts i k with
              | Some v => v
              | None => None
              end
            )
          ) in (
            clear nexts;
            set (nexts := nexts')
          )
        | None => idtac
        end;

        let j' := eval compute in j in
          clear j;
          set (j := S j')
      );
      clear j;

      let i' := eval compute in i in
        clear i;
        set (i := S i')
    );
    clear i;

    let k' := eval compute in k in
      clear k;
      set (k := S k')
  );
  clear k;
  exact (next_matrix_to_paths Node_eq_dec nodes num_nodes nexts).

Ltac prove_dynamic_policy_valid Node topology policy costs Node_eq_dec all_nodes paths policy_invariant :=
  let invariant_implies_path_exists := fresh "invariant_implies_path_exists" in
  let invariant_initial := fresh "invariant_initial" in
  let invariant_step := fresh "invariant_step" in
  assert (invariant_implies_path_exists : forall st current_flow,
    policy_invariant st
      -> policy_state_decider policy st current_flow = true
      -> paths current_flow.(Src) current_flow.(Dest) = None
      -> False
  );
  [
    idtac |
    assert (invariant_initial : policy_invariant policy.(policy_system).(Initial));
    [
      clear |
      assert (invariant_step : forall st current_flow,
        policy_invariant st
          -> policy.(policy_state_decider) st current_flow = true
          -> policy_invariant (policy.(policy_system).(Step) st current_flow)
      ); [clear | idtac]
    ]
  ];
  [ idtac | idtac | idtac |
    apply exist with (x := paths);
    apply invariant_weakening with (strong_condition := policy_invariant);
    match goal with
    | [ |- invariant _ policy_invariant ] =>
      unfold invariant;
      intros;
      unfold filter_transition_system in *;
      let start := fresh "start" in
      let Heqstart := fresh "Heqstart" in
      remember policy.(policy_system).(Initial) as start eqn:Heqstart;
      clear Heqstart;
      match goal with
      | [ H : trc _ _ _ |- _ ] =>
        simpl in H;
        dependent induction H;
        [ apply invariant_initial | idtac ];
        subst;
        match goal with
        | [ H : ?inv (if ?cond then _ else _) -> ?inv ?dest |- ?inv ?dest ] =>
          apply H;
          destruct_with_eqn (cond); try assumption;
          apply invariant_step; assumption
        | _ => idtac "in"
        end
      | _ => idtac "out"
      end
    | [ |- forall state, policy_invariant state -> all_pairs_paths_valid _ _ _ ] =>
      intros;
      constructor;
      intros;
      match goal with
      | [ |- match paths _ _ with | Some _ => _ | None => True end ] =>
        repeat match goal with
        | [ n : Node |- _ ] => destruct n
        end;
        simpl;
        tauto
      | [ |- match paths ?current_flow.(Src) ?current_flow.(Dest) with | Some _ => True | None => False end ] =>
        destruct_with_eqn (paths current_flow.(Src) current_flow.(Dest));
        [ tauto | idtac ];
        destruct current_flow;
        eapply invariant_implies_path_exists;
        eassumption
      | [ |- exists x, generates_decreasing_costs topology paths x ] =>
        exists costs;
        constructor;
        unfold only_positive_costs;
        intros;
        repeat match goal with
        | [ n : Node |- _ ] => destruct n; simpl
        end;
        intuition
      end
    end
  ].

Section NetworkExample.
  Local Inductive ExampleVertex :=
  | A
  | B
  | C
  | D
  | E
  | F
  .

  Definition all_nodes : {l : list ExampleVertex | Listing l} := ltac:(enumerate_finite_set).
  Definition ExampleVertex_eq_dec : forall x y : ExampleVertex, {x = y} + {x <> y} := ltac:(prove_decidable_equality).

  (*
    example_topology:

        B ------> E
      / | \       ↑
     A  |5 D <--- F
      \ | /
        C
  *)
  Local Definition example_topology n1 n2 :=
    match n1, n2 with
    (* Arbitrarily, the ports are numbered in increasing
       order at each node. *)
    | A, B => Some (natToWord 16 1)
    | B, A => Some (natToWord 16 1)
    | A, C => Some (natToWord 16 2)
    | C, A => Some (natToWord 16 1)
    | B, C => Some (natToWord 16 2)
    | C, B => Some (natToWord 16 2)
    | B, D => Some (natToWord 16 3)
    | D, B => Some (natToWord 16 1)
    | B, E => Some (natToWord 16 4)
    | C, D => Some (natToWord 16 3)
    | D, C => Some (natToWord 16 2)
    | F, D => Some (natToWord 16 1)
    | F, E => Some (natToWord 16 2)
    | _, _ => None
    end.

  (* Giving all edges a cost of 1 would not satisfy the decreasing-costs
  constraint, because when routing F to E, node B would choose
  a path of [C; A; B; E] which is not shorter than the original expected
  path from F of [D; C; B; E]. However, if the (C, B) edge
  has a large cost, then the total cost of [C; A; B; E] is less
  than the cost of [D; C; B; E]. *)
  Definition example_costs n1 port :=
    match n1 with
    | C => if weqb port (natToWord 16 2) then 5 else 1
    | _ => 1
    end.

  Local Definition example_all_pairs_paths : @all_pairs_paths ExampleVertex := ltac:(generate_all_pairs_paths ExampleVertex ExampleVertex_eq_dec example_topology all_nodes example_costs).

  Definition policy_satisfiable (policy : @static_network_policy ExampleVertex) := forall n1 n2,
    policy {| Src := n1; Dest := n2 |} = true -> example_all_pairs_paths n1 n2 <> None.

  Local Definition example_static_policy current_flow :=
    match current_flow.(Src), current_flow.(Dest) with
    | A, F | E, A => false
    | A, _ | _, A | F, _ => true
    | _, _ => false
    end.

  Definition ExampleVertex_eqb x y := if ExampleVertex_eq_dec x y then true else false.

  Fixpoint in_pair_list pair_list current_flow :=
    match pair_list with
    | [] => false
    | (src, dest) :: cdr => (ExampleVertex_eqb src current_flow.(Src) && ExampleVertex_eqb dest current_flow.(Dest)) || in_pair_list cdr current_flow
    end.

  (*
    Initial state: A can send to anywhere that it can reach
    After each successful packet from x to y, policy updates so y can also send to x, provided that y can reach x
  *)
  Definition example_dynamic_policy : @dynamic_network_policy ExampleVertex (list (ExampleVertex * ExampleVertex)) := {|
    policy_system := {|
      Initial := [(A, B); (A, C); (A, D)];
      Step := fun current_state last_flow =>
        if ExampleVertex_eq_dec F last_flow.(Src)
        then current_state
        else if ExampleVertex_eq_dec E last_flow.(Dest)
        then current_state
        else (last_flow.(Dest), last_flow.(Src)) :: current_state
    |};
    policy_state_decider := in_pair_list
  |}.

  Definition verified_example_paths : {paths : @all_pairs_paths ExampleVertex | dynamic_policy_valid example_topology example_dynamic_policy paths}.
  Proof.
    prove_dynamic_policy_valid ExampleVertex example_topology example_dynamic_policy example_costs ExampleVertex_eq_dec all_nodes example_all_pairs_paths (fix contains_valid_entries state := match state with
    | [] => True
    | (src, dest) :: cdr => src <> E /\ dest <> F /\ contains_valid_entries cdr
    end); intros.
    - unfold example_dynamic_policy in *; simpl in *; destruct current_flow; dependent induction st; try discriminate; simpl in *.
      repeat match goal with
      | [ H : let (_, _) := ?a in _ |- _ ] => destruct a
      | [ H : _ || _ = true |- _ ] => rewrite orb_true_iff in H
      | [ H : _ && _ = true |- _ ] => rewrite andb_true_iff in H
      | [ H : _ /\ _ |- _ ] => destruct H
      | [ H : _ \/ _ |- _ ] => destruct H
      | [ H : ExampleVertex_eqb ?a ?b = true |- _ ] => assert (a = b) by (destruct a, b; simpl in H; try reflexivity; discriminate); clear H; subst
      end; simpl in *; eapply IHst; try eassumption; repeat match goal with
      | [ x : ExampleVertex |- _ ] => destruct x
      end; try discriminate; tauto.
    - firstorder discriminate.
    - repeat match goal with
    | [ f : flow |- _ ] => destruct f
    | [ x : ExampleVertex |- _ ] => destruct x; simpl
    | [ |- _ /\ _ ] => constructor
    end; congruence.
  Defined.

  Definition example_node_ips_nat node :=
    match node with
    | A => (10, 0, 0, 1)
    | B => (10, 0, 0, 2)
    | C => (10, 0, 0, 3)
    | D => (10, 0, 0, 4)
    | E => (10, 0, 0, 5)
    | F => (10, 0, 0, 6)
    end.

  Definition node_ips node :=
    match example_node_ips_nat node with
    | (n1, n2, n3, n4) => (natToWord 8 n1, natToWord 8 n2, natToWord 8 n3, natToWord 8 n4)
    end.

  Definition generated_dynamic_controller := @dynamic_controller_generator
    ExampleVertex
    ExampleVertex_eq_dec
    (list (ExampleVertex * ExampleVertex))
    ltac:(prove_valid_topology example_topology)
    example_dynamic_policy
    verified_example_paths
    all_nodes
    ltac:(prove_injective_ips node_ips).
End NetworkExample.

Require Extraction.
Extraction Language OCaml.
Extract Inductive bool => "bool" [ "true" "false" ].
Extract Inductive sumbool => "bool" [ "true" "false" ].
Extract Inductive option => "option" [ "Some" "None" ].
Extract Inductive list => "list" [ "[]" "( :: )" ].
Extract Inductive prod => "( * )" [ "(, )" ].
Extraction "src/generated_controller.ml" generated_dynamic_controller.
